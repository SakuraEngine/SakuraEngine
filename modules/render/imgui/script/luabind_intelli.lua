--DO NOT EDIT THIS FILE, IT IS AUTO GENERATED BY CODEGEN


---@class IMGUI
---@field public WindowFlags_None integer 
---@field public WindowFlags_NoTitleBar integer @// Disable title-bar
---@field public WindowFlags_NoResize integer @// Disable user resizing with the lower-right grip
---@field public WindowFlags_NoMove integer @// Disable user moving the window
---@field public WindowFlags_NoScrollbar integer @// Disable scrollbars (window can still scroll with mouse or programmatically)
---@field public WindowFlags_NoScrollWithMouse integer @// Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.
---@field public WindowFlags_NoCollapse integer @// Disable user collapsing window by double-clicking on it. Also referred to as Window Menu Button (e.g. within a docking node).
---@field public WindowFlags_AlwaysAutoResize integer @// Resize every window to its content every frame
---@field public WindowFlags_NoBackground integer @// Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).
---@field public WindowFlags_NoSavedSettings integer @// Never load/save settings in .ini file
---@field public WindowFlags_NoMouseInputs integer @// Disable catching mouse, hovering test with pass through.
---@field public WindowFlags_MenuBar integer @// Has a menu-bar
---@field public WindowFlags_HorizontalScrollbar integer @// Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
---@field public WindowFlags_NoFocusOnAppearing integer @// Disable taking focus when transitioning from hidden to visible state
---@field public WindowFlags_NoBringToFrontOnFocus integer @// Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)
---@field public WindowFlags_AlwaysVerticalScrollbar integer @// Always show vertical scrollbar (even if ContentSize.y < Size.y)
---@field public WindowFlags_AlwaysHorizontalScrollbar integer @// Always show horizontal scrollbar (even if ContentSize.x < Size.x)
---@field public WindowFlags_AlwaysUseWindowPadding integer @// Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)
---@field public WindowFlags_NoNavInputs integer @// No gamepad/keyboard navigation within the window
---@field public WindowFlags_NoNavFocus integer @// No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)
---@field public WindowFlags_UnsavedDocument integer @// Display a dot next to the title. When used in a tab/docking context, tab is selected when clicking the X + closure is not assumed (will wait for user to stop submitting the tab). Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.
---@field public WindowFlags_NoDocking integer @// Disable docking of this window
---@field public WindowFlags_NoNav integer 
---@field public WindowFlags_NoDecoration integer 
---@field public WindowFlags_NoInputs integer 
---@field public WindowFlags_NavFlattened integer @// [BETA] On child window: allow gamepad/keyboard navigation to cross over parent border to this child or between sibling child windows.
---@field public WindowFlags_ChildWindow integer @// Don't use! For internal use by BeginChild()
---@field public WindowFlags_Tooltip integer @// Don't use! For internal use by BeginTooltip()
---@field public WindowFlags_Popup integer @// Don't use! For internal use by BeginPopup()
---@field public WindowFlags_Modal integer @// Don't use! For internal use by BeginPopupModal()
---@field public WindowFlags_ChildMenu integer @// Don't use! For internal use by BeginMenu()
---@field public WindowFlags_DockNodeHost integer @// Don't use! For internal use by Begin()/NewFrame()
---@field public InputTextFlags_None integer 
---@field public InputTextFlags_CharsDecimal integer @// Allow 0123456789.+-*/
---@field public InputTextFlags_CharsHexadecimal integer @// Allow 0123456789ABCDEFabcdef
---@field public InputTextFlags_CharsUppercase integer @// Turn a..z into A..Z
---@field public InputTextFlags_CharsNoBlank integer @// Filter out spaces, tabs
---@field public InputTextFlags_AutoSelectAll integer @// Select entire text when first taking mouse focus
---@field public InputTextFlags_EnterReturnsTrue integer @// Return 'true' when Enter is pressed (as opposed to every time the value was modified). Consider looking at the IsItemDeactivatedAfterEdit() function.
---@field public InputTextFlags_CallbackCompletion integer @// Callback on pressing TAB (for completion handling)
---@field public InputTextFlags_CallbackHistory integer @// Callback on pressing Up/Down arrows (for history handling)
---@field public InputTextFlags_CallbackAlways integer @// Callback on each iteration. User code may query cursor position, modify text buffer.
---@field public InputTextFlags_CallbackCharFilter integer @// Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
---@field public InputTextFlags_AllowTabInput integer @// Pressing TAB input a '\t' character into the text field
---@field public InputTextFlags_CtrlEnterForNewLine integer @// In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).
---@field public InputTextFlags_NoHorizontalScroll integer @// Disable following the cursor horizontally
---@field public InputTextFlags_AlwaysOverwrite integer @// Overwrite mode
---@field public InputTextFlags_ReadOnly integer @// Read-only mode
---@field public InputTextFlags_Password integer @// Password mode, display all characters as '*'
---@field public InputTextFlags_NoUndoRedo integer @// Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().
---@field public InputTextFlags_CharsScientific integer @// Allow 0123456789.+-*/eE (Scientific notation input)
---@field public InputTextFlags_CallbackResize integer @// Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this)
---@field public InputTextFlags_CallbackEdit integer @// Callback on any edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)
---@field public InputTextFlags_AlwaysInsertMode integer @// [renamed in 1.82] name was not matching behavior
---@field public TreeNodeFlags_None integer 
---@field public TreeNodeFlags_Selected integer @// Draw as selected
---@field public TreeNodeFlags_Framed integer @// Draw frame with background (e.g. for CollapsingHeader)
---@field public TreeNodeFlags_AllowItemOverlap integer @// Hit testing to allow subsequent widgets to overlap this one
---@field public TreeNodeFlags_NoTreePushOnOpen integer @// Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack
---@field public TreeNodeFlags_NoAutoOpenOnLog integer @// Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)
---@field public TreeNodeFlags_DefaultOpen integer @// Default node to be open
---@field public TreeNodeFlags_OpenOnDoubleClick integer @// Need double-click to open node
---@field public TreeNodeFlags_OpenOnArrow integer @// Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.
---@field public TreeNodeFlags_Leaf integer @// No collapsing, no arrow (use as a convenience for leaf nodes).
---@field public TreeNodeFlags_Bullet integer @// Display a bullet instead of arrow
---@field public TreeNodeFlags_FramePadding integer @// Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().
---@field public TreeNodeFlags_SpanAvailWidth integer @// Extend hit box to the right-most edge, even if not framed. This is not the default in order to allow adding other items on the same line. In the future we may refactor the hit system to be front-to-back, allowing natural overlaps and then this can become the default.
---@field public TreeNodeFlags_SpanFullWidth integer @// Extend hit box to the left-most and right-most edges (bypass the indented area).
---@field public TreeNodeFlags_NavLeftJumpsBackHere integer @// (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)
---@field public TreeNodeFlags_CollapsingHeader integer 
---@field public PopupFlags_None integer 
---@field public PopupFlags_MouseButtonLeft integer @// For BeginPopupContext*(): open on Left Mouse release. Guaranteed to always be == 0 (same as ImGuiMouseButton_Left)
---@field public PopupFlags_MouseButtonRight integer @// For BeginPopupContext*(): open on Right Mouse release. Guaranteed to always be == 1 (same as ImGuiMouseButton_Right)
---@field public PopupFlags_MouseButtonMiddle integer @// For BeginPopupContext*(): open on Middle Mouse release. Guaranteed to always be == 2 (same as ImGuiMouseButton_Middle)
---@field public PopupFlags_MouseButtonMask_ integer 
---@field public PopupFlags_MouseButtonDefault_ integer 
---@field public PopupFlags_NoOpenOverExistingPopup integer @// For OpenPopup*(), BeginPopupContext*(): don't open if there's already a popup at the same level of the popup stack
---@field public PopupFlags_NoOpenOverItems integer @// For BeginPopupContextWindow(): don't return true when hovering items, only when hovering empty space
---@field public PopupFlags_AnyPopupId integer @// For IsPopupOpen(): ignore the ImGuiID parameter and test for any popup.
---@field public PopupFlags_AnyPopupLevel integer @// For IsPopupOpen(): search/test at any level of the popup stack (default test in the current level)
---@field public PopupFlags_AnyPopup integer 
---@field public SelectableFlags_None integer 
---@field public SelectableFlags_DontClosePopups integer @// Clicking this don't close parent popup window
---@field public SelectableFlags_SpanAllColumns integer @// Selectable frame can span all columns (text will still fit in current column)
---@field public SelectableFlags_AllowDoubleClick integer @// Generate press events on double clicks too
---@field public SelectableFlags_Disabled integer @// Cannot be selected, display grayed out text
---@field public SelectableFlags_AllowItemOverlap integer @// (WIP) Hit testing to allow subsequent widgets to overlap this one
---@field public ComboFlags_None integer 
---@field public ComboFlags_PopupAlignLeft integer @// Align the popup toward the left by default
---@field public ComboFlags_HeightSmall integer @// Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()
---@field public ComboFlags_HeightRegular integer @// Max ~8 items visible (default)
---@field public ComboFlags_HeightLarge integer @// Max ~20 items visible
---@field public ComboFlags_HeightLargest integer @// As many fitting items as possible
---@field public ComboFlags_NoArrowButton integer @// Display on the preview box without the square arrow button
---@field public ComboFlags_NoPreview integer @// Display only a square arrow button
---@field public ComboFlags_HeightMask_ integer 
---@field public TabBarFlags_None integer 
---@field public TabBarFlags_Reorderable integer @// Allow manually dragging tabs to re-order them + New tabs are appended at the end of list
---@field public TabBarFlags_AutoSelectNewTabs integer @// Automatically select new tabs when they appear
---@field public TabBarFlags_TabListPopupButton integer @// Disable buttons to open the tab list popup
---@field public TabBarFlags_NoCloseWithMiddleMouseButton integer @// Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
---@field public TabBarFlags_NoTabListScrollingButtons integer @// Disable scrolling buttons (apply when fitting policy is ImGuiTabBarFlags_FittingPolicyScroll)
---@field public TabBarFlags_NoTooltip integer @// Disable tooltips when hovering a tab
---@field public TabBarFlags_FittingPolicyResizeDown integer @// Resize tabs when they don't fit
---@field public TabBarFlags_FittingPolicyScroll integer @// Add scroll buttons when tabs don't fit
---@field public TabBarFlags_FittingPolicyMask_ integer 
---@field public TabBarFlags_FittingPolicyDefault_ integer 
---@field public TabItemFlags_None integer 
---@field public TabItemFlags_UnsavedDocument integer @// Display a dot next to the title + tab is selected when clicking the X + closure is not assumed (will wait for user to stop submitting the tab). Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.
---@field public TabItemFlags_SetSelected integer @// Trigger flag to programmatically make the tab selected when calling BeginTabItem()
---@field public TabItemFlags_NoCloseWithMiddleMouseButton integer @// Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
---@field public TabItemFlags_NoPushId integer @// Don't call PushID(tab->ID)/PopID() on BeginTabItem()/EndTabItem()
---@field public TabItemFlags_NoTooltip integer @// Disable tooltip for the given tab
---@field public TabItemFlags_NoReorder integer @// Disable reordering this tab or having another tab cross over this tab
---@field public TabItemFlags_Leading integer @// Enforce the tab position to the left of the tab bar (after the tab list popup button)
---@field public TabItemFlags_Trailing integer @// Enforce the tab position to the right of the tab bar (before the scrolling buttons)
---@field public TableFlags_None integer 
---@field public TableFlags_Resizable integer @// Enable resizing columns.
---@field public TableFlags_Reorderable integer @// Enable reordering columns in header row (need calling TableSetupColumn() + TableHeadersRow() to display headers)
---@field public TableFlags_Hideable integer @// Enable hiding/disabling columns in context menu.
---@field public TableFlags_Sortable integer @// Enable sorting. Call TableGetSortSpecs() to obtain sort specs. Also see ImGuiTableFlags_SortMulti and ImGuiTableFlags_SortTristate.
---@field public TableFlags_NoSavedSettings integer @// Disable persisting columns order, width and sort settings in the .ini file.
---@field public TableFlags_ContextMenuInBody integer @// Right-click on columns body/contents will display table context menu. By default it is available in TableHeadersRow().
---@field public TableFlags_RowBg integer @// Set each RowBg color with ImGuiCol_TableRowBg or ImGuiCol_TableRowBgAlt (equivalent of calling TableSetBgColor with ImGuiTableBgFlags_RowBg0 on each row manually)
---@field public TableFlags_BordersInnerH integer @// Draw horizontal borders between rows.
---@field public TableFlags_BordersOuterH integer @// Draw horizontal borders at the top and bottom.
---@field public TableFlags_BordersInnerV integer @// Draw vertical borders between columns.
---@field public TableFlags_BordersOuterV integer @// Draw vertical borders on the left and right sides.
---@field public TableFlags_BordersH integer @// Draw horizontal borders.
---@field public TableFlags_BordersV integer @// Draw vertical borders.
---@field public TableFlags_BordersInner integer @// Draw inner borders.
---@field public TableFlags_BordersOuter integer @// Draw outer borders.
---@field public TableFlags_Borders integer @// Draw all borders.
---@field public TableFlags_NoBordersInBody integer @// [ALPHA] Disable vertical borders in columns Body (borders will always appears in Headers). -> May move to style
---@field public TableFlags_NoBordersInBodyUntilResize integer @// [ALPHA] Disable vertical borders in columns Body until hovered for resize (borders will always appears in Headers). -> May move to style
---@field public TableFlags_SizingFixedFit integer @// Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching contents width.
---@field public TableFlags_SizingFixedSame integer @// Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching the maximum contents width of all columns. Implicitly enable ImGuiTableFlags_NoKeepColumnsVisible.
---@field public TableFlags_SizingStretchProp integer @// Columns default to _WidthStretch with default weights proportional to each columns contents widths.
---@field public TableFlags_SizingStretchSame integer @// Columns default to _WidthStretch with default weights all equal, unless overridden by TableSetupColumn().
---@field public TableFlags_NoHostExtendX integer @// Make outer width auto-fit to columns, overriding outer_size.x value. Only available when ScrollX/ScrollY are disabled and Stretch columns are not used.
---@field public TableFlags_NoHostExtendY integer @// Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit). Only available when ScrollX/ScrollY are disabled. Data below the limit will be clipped and not visible.
---@field public TableFlags_NoKeepColumnsVisible integer @// Disable keeping column always minimally visible when ScrollX is off and table gets too small. Not recommended if columns are resizable.
---@field public TableFlags_PreciseWidths integer @// Disable distributing remainder width to stretched columns (width allocation on a 100-wide table with 3 columns: Without this flag: 33,33,34. With this flag: 33,33,33). With larger number of columns, resizing will appear to be less smooth.
---@field public TableFlags_NoClip integer @// Disable clipping rectangle for every individual columns (reduce draw command count, items will be able to overflow into other columns). Generally incompatible with TableSetupScrollFreeze().
---@field public TableFlags_PadOuterX integer @// Default if BordersOuterV is on. Enable outer-most padding. Generally desirable if you have headers.
---@field public TableFlags_NoPadOuterX integer @// Default if BordersOuterV is off. Disable outer-most padding.
---@field public TableFlags_NoPadInnerX integer @// Disable inner padding between columns (double inner padding if BordersOuterV is on, single inner padding if BordersOuterV is off).
---@field public TableFlags_ScrollX integer @// Enable horizontal scrolling. Require 'outer_size' parameter of BeginTable() to specify the container size. Changes default sizing policy. Because this create a child window, ScrollY is currently generally recommended when using ScrollX.
---@field public TableFlags_ScrollY integer @// Enable vertical scrolling. Require 'outer_size' parameter of BeginTable() to specify the container size.
---@field public TableFlags_SortMulti integer @// Hold shift when clicking headers to sort on multiple column. TableGetSortSpecs() may return specs where (SpecsCount > 1).
---@field public TableFlags_SortTristate integer @// Allow no sorting, disable default sorting. TableGetSortSpecs() may return specs where (SpecsCount == 0).
---@field public TableFlags_SizingMask_ integer 
---@field public TableColumnFlags_None integer 
---@field public TableColumnFlags_Disabled integer @// Overriding/master disable flag: hide column, won't show in context menu (unlike calling TableSetColumnEnabled() which manipulates the user accessible state)
---@field public TableColumnFlags_DefaultHide integer @// Default as a hidden/disabled column.
---@field public TableColumnFlags_DefaultSort integer @// Default as a sorting column.
---@field public TableColumnFlags_WidthStretch integer @// Column will stretch. Preferable with horizontal scrolling disabled (default if table sizing policy is _SizingStretchSame or _SizingStretchProp).
---@field public TableColumnFlags_WidthFixed integer @// Column will not stretch. Preferable with horizontal scrolling enabled (default if table sizing policy is _SizingFixedFit and table is resizable).
---@field public TableColumnFlags_NoResize integer @// Disable manual resizing.
---@field public TableColumnFlags_NoReorder integer @// Disable manual reordering this column, this will also prevent other columns from crossing over this column.
---@field public TableColumnFlags_NoHide integer @// Disable ability to hide/disable this column.
---@field public TableColumnFlags_NoClip integer @// Disable clipping for this column (all NoClip columns will render in a same draw command).
---@field public TableColumnFlags_NoSort integer @// Disable ability to sort on this field (even if ImGuiTableFlags_Sortable is set on the table).
---@field public TableColumnFlags_NoSortAscending integer @// Disable ability to sort in the ascending direction.
---@field public TableColumnFlags_NoSortDescending integer @// Disable ability to sort in the descending direction.
---@field public TableColumnFlags_NoHeaderLabel integer @// TableHeadersRow() will not submit label for this column. Convenient for some small columns. Name will still appear in context menu.
---@field public TableColumnFlags_NoHeaderWidth integer @// Disable header text width contribution to automatic column width.
---@field public TableColumnFlags_PreferSortAscending integer @// Make the initial sort direction Ascending when first sorting on this column (default).
---@field public TableColumnFlags_PreferSortDescending integer @// Make the initial sort direction Descending when first sorting on this column.
---@field public TableColumnFlags_IndentEnable integer @// Use current Indent value when entering cell (default for column 0).
---@field public TableColumnFlags_IndentDisable integer @// Ignore current Indent value when entering cell (default for columns > 0). Indentation changes _within_ the cell will still be honored.
---@field public TableColumnFlags_IsEnabled integer @// Status: is enabled == not hidden by user/api (referred to as "Hide" in _DefaultHide and _NoHide) flags.
---@field public TableColumnFlags_IsVisible integer @// Status: is visible == is enabled AND not clipped by scrolling.
---@field public TableColumnFlags_IsSorted integer @// Status: is currently part of the sort specs
---@field public TableColumnFlags_IsHovered integer @// Status: is hovered by mouse
---@field public TableColumnFlags_WidthMask_ integer 
---@field public TableColumnFlags_IndentMask_ integer 
---@field public TableColumnFlags_StatusMask_ integer 
---@field public TableColumnFlags_NoDirectResize_ integer @// [Internal] Disable user resizing this column directly (it may however we resized indirectly from its left edge)
---@field public TableRowFlags_None integer 
---@field public TableRowFlags_Headers integer @// Identify header row (set default background color + width of its contents accounted differently for auto column width)
---@field public TableBgTarget_None integer 
---@field public TableBgTarget_RowBg0 integer @// Set row background color 0 (generally used for background, automatically set when ImGuiTableFlags_RowBg is used)
---@field public TableBgTarget_RowBg1 integer @// Set row background color 1 (generally used for selection marking)
---@field public TableBgTarget_CellBg integer @// Set cell background color (top-most color)
---@field public FocusedFlags_None integer 
---@field public FocusedFlags_ChildWindows integer @// Return true if any children of the window is focused
---@field public FocusedFlags_RootWindow integer @// Test from root window (top most parent of the current hierarchy)
---@field public FocusedFlags_AnyWindow integer @// Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use 'io.WantCaptureMouse' instead! Please read the FAQ!
---@field public FocusedFlags_NoPopupHierarchy integer @// Do not consider popup hierarchy (do not treat popup emitter as parent of popup) (when used with _ChildWindows or _RootWindow)
---@field public FocusedFlags_DockHierarchy integer @// Consider docking hierarchy (treat dockspace host as parent of docked window) (when used with _ChildWindows or _RootWindow)
---@field public FocusedFlags_RootAndChildWindows integer 
---@field public HoveredFlags_None integer @// Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.
---@field public HoveredFlags_ChildWindows integer @// IsWindowHovered() only: Return true if any children of the window is hovered
---@field public HoveredFlags_RootWindow integer @// IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)
---@field public HoveredFlags_AnyWindow integer @// IsWindowHovered() only: Return true if any window is hovered
---@field public HoveredFlags_NoPopupHierarchy integer @// IsWindowHovered() only: Do not consider popup hierarchy (do not treat popup emitter as parent of popup) (when used with _ChildWindows or _RootWindow)
---@field public HoveredFlags_DockHierarchy integer @// IsWindowHovered() only: Consider docking hierarchy (treat dockspace host as parent of docked window) (when used with _ChildWindows or _RootWindow)
---@field public HoveredFlags_AllowWhenBlockedByPopup integer @// Return true even if a popup window is normally blocking access to this item/window
---@field public HoveredFlags_AllowWhenBlockedByActiveItem integer @// Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.
---@field public HoveredFlags_AllowWhenOverlapped integer @// IsItemHovered() only: Return true even if the position is obstructed or overlapped by another window
---@field public HoveredFlags_AllowWhenDisabled integer @// IsItemHovered() only: Return true even if the item is disabled
---@field public HoveredFlags_NoNavOverride integer @// Disable using gamepad/keyboard navigation state when active, always query mouse.
---@field public HoveredFlags_RectOnly integer 
---@field public HoveredFlags_RootAndChildWindows integer 
---@field public HoveredFlags_DelayNormal integer @// Return true after io.HoverDelayNormal elapsed (~0.30 sec)
---@field public HoveredFlags_DelayShort integer @// Return true after io.HoverDelayShort elapsed (~0.10 sec)
---@field public HoveredFlags_NoSharedDelay integer @// Disable shared delay system where moving from one item to the next keeps the previous timer for a short time (standard for tooltips with long delays)
---@field public DockNodeFlags_None integer 
---@field public DockNodeFlags_KeepAliveOnly integer @// Shared       // Don't display the dockspace node but keep it alive. Windows docked into this dockspace node won't be undocked.
---@field public DockNodeFlags_NoDockingInCentralNode integer @// Shared       // Disable docking inside the Central Node, which will be always kept empty.
---@field public DockNodeFlags_PassthruCentralNode integer @// Shared       // Enable passthru dockspace: 1) DockSpace() will render a ImGuiCol_WindowBg background covering everything excepted the Central Node when empty. Meaning the host window should probably use SetNextWindowBgAlpha(0.0f) prior to Begin() when using this. 2) When Central Node is empty: let inputs pass-through + won't display a DockingEmptyBg background. See demo for details.
---@field public DockNodeFlags_NoSplit integer @// Shared/Local // Disable splitting the node into smaller nodes. Useful e.g. when embedding dockspaces into a main root one (the root one may have splitting disabled to reduce confusion). Note: when turned off, existing splits will be preserved.
---@field public DockNodeFlags_NoResize integer @// Shared/Local // Disable resizing node using the splitter/separators. Useful with programmatically setup dockspaces.
---@field public DockNodeFlags_AutoHideTabBar integer @// Shared/Local // Tab bar will automatically hide when there is a single window in the dock node.
---@field public DragDropFlags_None integer 
---@field public DragDropFlags_SourceNoPreviewTooltip integer @// By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.
---@field public DragDropFlags_SourceNoDisableHover integer @// By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.
---@field public DragDropFlags_SourceNoHoldToOpenOthers integer @// Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.
---@field public DragDropFlags_SourceAllowNullID integer @// Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.
---@field public DragDropFlags_SourceExtern integer @// External source (from outside of dear imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.
---@field public DragDropFlags_SourceAutoExpirePayload integer @// Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)
---@field public DragDropFlags_AcceptBeforeDelivery integer @// AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.
---@field public DragDropFlags_AcceptNoDrawDefaultRect integer @// Do not draw the default highlight rectangle when hovering over target.
---@field public DragDropFlags_AcceptNoPreviewTooltip integer @// Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.
---@field public DragDropFlags_AcceptPeekOnly integer @// For peeking ahead and inspecting the payload before delivery.
---@field public DataType_S8 integer @// signed char / char (with sensible compilers)
---@field public DataType_U8 integer @// unsigned char
---@field public DataType_S16 integer @// short
---@field public DataType_U16 integer @// unsigned short
---@field public DataType_S32 integer @// int
---@field public DataType_U32 integer @// unsigned int
---@field public DataType_S64 integer @// long long / __int64
---@field public DataType_U64 integer @// unsigned long long / unsigned __int64
---@field public DataType_Float integer @// float
---@field public DataType_Double integer @// double
---@field public DataType_COUNT integer 
---@field public Dir_None integer 
---@field public Dir_Left integer 
---@field public Dir_Right integer 
---@field public Dir_Up integer 
---@field public Dir_Down integer 
---@field public Dir_COUNT integer 
---@field public SortDirection_None integer 
---@field public SortDirection_Ascending integer @// Ascending = 0->9, A->Z etc.
---@field public SortDirection_Descending integer @// Descending = 9->0, Z->A etc.
---@field public Key_None integer 
---@field public Key_Tab integer @// == ImGuiKey_NamedKey_BEGIN
---@field public Key_LeftArrow integer 
---@field public Key_RightArrow integer 
---@field public Key_UpArrow integer 
---@field public Key_DownArrow integer 
---@field public Key_PageUp integer 
---@field public Key_PageDown integer 
---@field public Key_Home integer 
---@field public Key_End integer 
---@field public Key_Insert integer 
---@field public Key_Delete integer 
---@field public Key_Backspace integer 
---@field public Key_Space integer 
---@field public Key_Enter integer 
---@field public Key_Escape integer 
---@field public Key_LeftCtrl integer 
---@field public Key_LeftShift integer 
---@field public Key_LeftAlt integer 
---@field public Key_LeftSuper integer 
---@field public Key_RightCtrl integer 
---@field public Key_RightShift integer 
---@field public Key_RightAlt integer 
---@field public Key_RightSuper integer 
---@field public Key_Menu integer 
---@field public Key_0 integer 
---@field public Key_1 integer 
---@field public Key_2 integer 
---@field public Key_3 integer 
---@field public Key_4 integer 
---@field public Key_5 integer 
---@field public Key_6 integer 
---@field public Key_7 integer 
---@field public Key_8 integer 
---@field public Key_9 integer 
---@field public Key_A integer 
---@field public Key_B integer 
---@field public Key_C integer 
---@field public Key_D integer 
---@field public Key_E integer 
---@field public Key_F integer 
---@field public Key_G integer 
---@field public Key_H integer 
---@field public Key_I integer 
---@field public Key_J integer 
---@field public Key_K integer 
---@field public Key_L integer 
---@field public Key_M integer 
---@field public Key_N integer 
---@field public Key_O integer 
---@field public Key_P integer 
---@field public Key_Q integer 
---@field public Key_R integer 
---@field public Key_S integer 
---@field public Key_T integer 
---@field public Key_U integer 
---@field public Key_V integer 
---@field public Key_W integer 
---@field public Key_X integer 
---@field public Key_Y integer 
---@field public Key_Z integer 
---@field public Key_F1 integer 
---@field public Key_F2 integer 
---@field public Key_F3 integer 
---@field public Key_F4 integer 
---@field public Key_F5 integer 
---@field public Key_F6 integer 
---@field public Key_F7 integer 
---@field public Key_F8 integer 
---@field public Key_F9 integer 
---@field public Key_F10 integer 
---@field public Key_F11 integer 
---@field public Key_F12 integer 
---@field public Key_Apostrophe integer @// '
---@field public Key_Comma integer @// ,
---@field public Key_Minus integer @// -
---@field public Key_Period integer @// .
---@field public Key_Slash integer @// /
---@field public Key_Semicolon integer @// ;
---@field public Key_Equal integer @// =
---@field public Key_LeftBracket integer @// [
---@field public Key_Backslash integer @// \ (this text inhibit multiline comment caused by backslash)
---@field public Key_RightBracket integer @// ]
---@field public Key_GraveAccent integer @// `
---@field public Key_CapsLock integer 
---@field public Key_ScrollLock integer 
---@field public Key_NumLock integer 
---@field public Key_PrintScreen integer 
---@field public Key_Pause integer 
---@field public Key_Keypad0 integer 
---@field public Key_Keypad1 integer 
---@field public Key_Keypad2 integer 
---@field public Key_Keypad3 integer 
---@field public Key_Keypad4 integer 
---@field public Key_Keypad5 integer 
---@field public Key_Keypad6 integer 
---@field public Key_Keypad7 integer 
---@field public Key_Keypad8 integer 
---@field public Key_Keypad9 integer 
---@field public Key_KeypadDecimal integer 
---@field public Key_KeypadDivide integer 
---@field public Key_KeypadMultiply integer 
---@field public Key_KeypadSubtract integer 
---@field public Key_KeypadAdd integer 
---@field public Key_KeypadEnter integer 
---@field public Key_KeypadEqual integer 
---@field public Key_GamepadStart integer @// Menu (Xbox)      + (Switch)   Start/Options (PS)
---@field public Key_GamepadBack integer @// View (Xbox)      - (Switch)   Share (PS)
---@field public Key_GamepadFaceLeft integer @// X (Xbox)         Y (Switch)   Square (PS)        // Tap: Toggle Menu. Hold: Windowing mode (Focus/Move/Resize windows)
---@field public Key_GamepadFaceRight integer @// B (Xbox)         A (Switch)   Circle (PS)        // Cancel / Close / Exit
---@field public Key_GamepadFaceUp integer @// Y (Xbox)         X (Switch)   Triangle (PS)      // Text Input / On-screen Keyboard
---@field public Key_GamepadFaceDown integer @// A (Xbox)         B (Switch)   Cross (PS)         // Activate / Open / Toggle / Tweak
---@field public Key_GamepadDpadLeft integer @// D-pad Left                                       // Move / Tweak / Resize Window (in Windowing mode)
---@field public Key_GamepadDpadRight integer @// D-pad Right                                      // Move / Tweak / Resize Window (in Windowing mode)
---@field public Key_GamepadDpadUp integer @// D-pad Up                                         // Move / Tweak / Resize Window (in Windowing mode)
---@field public Key_GamepadDpadDown integer @// D-pad Down                                       // Move / Tweak / Resize Window (in Windowing mode)
---@field public Key_GamepadL1 integer @// L Bumper (Xbox)  L (Switch)   L1 (PS)            // Tweak Slower / Focus Previous (in Windowing mode)
---@field public Key_GamepadR1 integer @// R Bumper (Xbox)  R (Switch)   R1 (PS)            // Tweak Faster / Focus Next (in Windowing mode)
---@field public Key_GamepadL2 integer @// L Trig. (Xbox)   ZL (Switch)  L2 (PS) [Analog]
---@field public Key_GamepadR2 integer @// R Trig. (Xbox)   ZR (Switch)  R2 (PS) [Analog]
---@field public Key_GamepadL3 integer @// L Stick (Xbox)   L3 (Switch)  L3 (PS)
---@field public Key_GamepadR3 integer @// R Stick (Xbox)   R3 (Switch)  R3 (PS)
---@field public Key_GamepadLStickLeft integer @// [Analog]                                         // Move Window (in Windowing mode)
---@field public Key_GamepadLStickRight integer @// [Analog]                                         // Move Window (in Windowing mode)
---@field public Key_GamepadLStickUp integer @// [Analog]                                         // Move Window (in Windowing mode)
---@field public Key_GamepadLStickDown integer @// [Analog]                                         // Move Window (in Windowing mode)
---@field public Key_GamepadRStickLeft integer @// [Analog]
---@field public Key_GamepadRStickRight integer @// [Analog]
---@field public Key_GamepadRStickUp integer @// [Analog]
---@field public Key_GamepadRStickDown integer @// [Analog]
---@field public Key_ModCtrl integer 
---@field public Key_ModShift integer 
---@field public Key_ModAlt integer 
---@field public Key_ModSuper integer 
---@field public Key_MouseLeft integer 
---@field public Key_MouseRight integer 
---@field public Key_MouseMiddle integer 
---@field public Key_MouseX1 integer 
---@field public Key_MouseX2 integer 
---@field public Key_MouseWheelX integer 
---@field public Key_MouseWheelY integer 
---@field public Key_COUNT integer @// No valid ImGuiKey is ever greater than this value
---@field public Key_NamedKey_BEGIN integer 
---@field public Key_NamedKey_END integer 
---@field public Key_NamedKey_COUNT integer 
---@field public Key_KeysData_SIZE integer @// Size of KeysData[]: only hold named keys
---@field public Key_KeysData_OFFSET integer @// First key stored in io.KeysData[0]. Accesses to io.KeysData[] must use (key - ImGuiKey_KeysData_OFFSET).
---@field public Key_KeysData_SIZE integer @// Size of KeysData[]: hold legacy 0..512 keycodes + named keys
---@field public Key_KeysData_OFFSET integer @// First key stored in io.KeysData[0]. Accesses to io.KeysData[] must use (key - ImGuiKey_KeysData_OFFSET).
---@field public Key_KeyPadEnter integer @// Renamed in 1.87
---@field public ModFlags_None integer 
---@field public ModFlags_Ctrl integer 
---@field public ModFlags_Shift integer 
---@field public ModFlags_Alt integer @// Option/Menu key
---@field public ModFlags_Super integer @// Cmd/Super/Windows key
---@field public ModFlags_All integer 
---@field public NavInput_Activate integer 
---@field public NavInput_Cancel integer 
---@field public NavInput_Input integer 
---@field public NavInput_Menu integer 
---@field public NavInput_DpadLeft integer 
---@field public NavInput_DpadRight integer 
---@field public NavInput_DpadUp integer 
---@field public NavInput_DpadDown integer 
---@field public NavInput_LStickLeft integer 
---@field public NavInput_LStickRight integer 
---@field public NavInput_LStickUp integer 
---@field public NavInput_LStickDown integer 
---@field public NavInput_FocusPrev integer 
---@field public NavInput_FocusNext integer 
---@field public NavInput_TweakSlow integer 
---@field public NavInput_TweakFast integer 
---@field public NavInput_COUNT integer 
---@field public ConfigFlags_None integer 
---@field public ConfigFlags_NavEnableKeyboard integer @// Master keyboard navigation enable flag.
---@field public ConfigFlags_NavEnableGamepad integer @// Master gamepad navigation enable flag. Backend also needs to set ImGuiBackendFlags_HasGamepad.
---@field public ConfigFlags_NavEnableSetMousePos integer @// Instruct navigation to move the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantSetMousePos=true. If enabled you MUST honor io.WantSetMousePos requests in your backend, otherwise ImGui will react as if the mouse is jumping around back and forth.
---@field public ConfigFlags_NavNoCaptureKeyboard integer @// Instruct navigation to not set the io.WantCaptureKeyboard flag when io.NavActive is set.
---@field public ConfigFlags_NoMouse integer @// Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information set by the backend.
---@field public ConfigFlags_NoMouseCursorChange integer @// Instruct backend to not alter mouse cursor shape and visibility. Use if the backend cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.
---@field public ConfigFlags_DockingEnable integer @// Docking enable flags.
---@field public ConfigFlags_ViewportsEnable integer @// Viewport enable flags (require both ImGuiBackendFlags_PlatformHasViewports + ImGuiBackendFlags_RendererHasViewports set by the respective backends)
---@field public ConfigFlags_DpiEnableScaleViewports integer @// [BETA: Don't use] FIXME-DPI: Reposition and resize imgui windows when the DpiScale of a viewport changed (mostly useful for the main viewport hosting other window). Note that resizing the main window itself is up to your application.
---@field public ConfigFlags_DpiEnableScaleFonts integer @// [BETA: Don't use] FIXME-DPI: Request bitmap-scaled fonts to match DpiScale. This is a very low-quality workaround. The correct way to handle DPI is _currently_ to replace the atlas and/or fonts in the Platform_OnChangedViewport callback, but this is all early work in progress.
---@field public ConfigFlags_IsSRGB integer @// Application is SRGB-aware.
---@field public ConfigFlags_IsTouchScreen integer @// Application is using a touch screen instead of a mouse.
---@field public BackendFlags_None integer 
---@field public BackendFlags_HasGamepad integer @// Backend Platform supports gamepad and currently has one connected.
---@field public BackendFlags_HasMouseCursors integer @// Backend Platform supports honoring GetMouseCursor() value to change the OS cursor shape.
---@field public BackendFlags_HasSetMousePos integer @// Backend Platform supports io.WantSetMousePos requests to reposition the OS mouse position (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).
---@field public BackendFlags_RendererHasVtxOffset integer @// Backend Renderer supports ImDrawCmd::VtxOffset. This enables output of large meshes (64K+ vertices) while still using 16-bit indices.
---@field public BackendFlags_PlatformHasViewports integer @// Backend Platform supports multiple viewports.
---@field public BackendFlags_HasMouseHoveredViewport integer @// Backend Platform supports calling io.AddMouseViewportEvent() with the viewport under the mouse. IF POSSIBLE, ignore viewports with the ImGuiViewportFlags_NoInputs flag (Win32 backend, GLFW 3.30+ backend can do this, SDL backend cannot). If this cannot be done, Dear ImGui needs to use a flawed heuristic to find the viewport under.
---@field public BackendFlags_RendererHasViewports integer @// Backend Renderer supports multiple viewports.
---@field public Col_Text integer 
---@field public Col_TextDisabled integer 
---@field public Col_WindowBg integer @// Background of normal windows
---@field public Col_ChildBg integer @// Background of child windows
---@field public Col_PopupBg integer @// Background of popups, menus, tooltips windows
---@field public Col_Border integer 
---@field public Col_BorderShadow integer 
---@field public Col_FrameBg integer @// Background of checkbox, radio button, plot, slider, text input
---@field public Col_FrameBgHovered integer 
---@field public Col_FrameBgActive integer 
---@field public Col_TitleBg integer 
---@field public Col_TitleBgActive integer 
---@field public Col_TitleBgCollapsed integer 
---@field public Col_MenuBarBg integer 
---@field public Col_ScrollbarBg integer 
---@field public Col_ScrollbarGrab integer 
---@field public Col_ScrollbarGrabHovered integer 
---@field public Col_ScrollbarGrabActive integer 
---@field public Col_CheckMark integer 
---@field public Col_SliderGrab integer 
---@field public Col_SliderGrabActive integer 
---@field public Col_Button integer 
---@field public Col_ButtonHovered integer 
---@field public Col_ButtonActive integer 
---@field public Col_Header integer @// Header* colors are used for CollapsingHeader, TreeNode, Selectable, MenuItem
---@field public Col_HeaderHovered integer 
---@field public Col_HeaderActive integer 
---@field public Col_Separator integer 
---@field public Col_SeparatorHovered integer 
---@field public Col_SeparatorActive integer 
---@field public Col_ResizeGrip integer @// Resize grip in lower-right and lower-left corners of windows.
---@field public Col_ResizeGripHovered integer 
---@field public Col_ResizeGripActive integer 
---@field public Col_Tab integer @// TabItem in a TabBar
---@field public Col_TabHovered integer 
---@field public Col_TabActive integer 
---@field public Col_TabUnfocused integer 
---@field public Col_TabUnfocusedActive integer 
---@field public Col_DockingPreview integer @// Preview overlay color when about to docking something
---@field public Col_DockingEmptyBg integer @// Background color for empty node (e.g. CentralNode with no window docked into it)
---@field public Col_PlotLines integer 
---@field public Col_PlotLinesHovered integer 
---@field public Col_PlotHistogram integer 
---@field public Col_PlotHistogramHovered integer 
---@field public Col_TableHeaderBg integer @// Table header background
---@field public Col_TableBorderStrong integer @// Table outer and header borders (prefer using Alpha=1.0 here)
---@field public Col_TableBorderLight integer @// Table inner borders (prefer using Alpha=1.0 here)
---@field public Col_TableRowBg integer @// Table row background (even rows)
---@field public Col_TableRowBgAlt integer @// Table row background (odd rows)
---@field public Col_TextSelectedBg integer 
---@field public Col_DragDropTarget integer @// Rectangle highlighting a drop target
---@field public Col_NavHighlight integer @// Gamepad/keyboard: current highlighted item
---@field public Col_NavWindowingHighlight integer @// Highlight window when using CTRL+TAB
---@field public Col_NavWindowingDimBg integer @// Darken/colorize entire screen behind the CTRL+TAB window list, when active
---@field public Col_ModalWindowDimBg integer @// Darken/colorize entire screen behind a modal window, when one is active
---@field public Col_COUNT integer 
---@field public StyleVar_Alpha integer @// float     Alpha
---@field public StyleVar_DisabledAlpha integer @// float     DisabledAlpha
---@field public StyleVar_WindowPadding integer @// ImVec2    WindowPadding
---@field public StyleVar_WindowRounding integer @// float     WindowRounding
---@field public StyleVar_WindowBorderSize integer @// float     WindowBorderSize
---@field public StyleVar_WindowMinSize integer @// ImVec2    WindowMinSize
---@field public StyleVar_WindowTitleAlign integer @// ImVec2    WindowTitleAlign
---@field public StyleVar_ChildRounding integer @// float     ChildRounding
---@field public StyleVar_ChildBorderSize integer @// float     ChildBorderSize
---@field public StyleVar_PopupRounding integer @// float     PopupRounding
---@field public StyleVar_PopupBorderSize integer @// float     PopupBorderSize
---@field public StyleVar_FramePadding integer @// ImVec2    FramePadding
---@field public StyleVar_FrameRounding integer @// float     FrameRounding
---@field public StyleVar_FrameBorderSize integer @// float     FrameBorderSize
---@field public StyleVar_ItemSpacing integer @// ImVec2    ItemSpacing
---@field public StyleVar_ItemInnerSpacing integer @// ImVec2    ItemInnerSpacing
---@field public StyleVar_IndentSpacing integer @// float     IndentSpacing
---@field public StyleVar_CellPadding integer @// ImVec2    CellPadding
---@field public StyleVar_ScrollbarSize integer @// float     ScrollbarSize
---@field public StyleVar_ScrollbarRounding integer @// float     ScrollbarRounding
---@field public StyleVar_GrabMinSize integer @// float     GrabMinSize
---@field public StyleVar_GrabRounding integer @// float     GrabRounding
---@field public StyleVar_TabRounding integer @// float     TabRounding
---@field public StyleVar_ButtonTextAlign integer @// ImVec2    ButtonTextAlign
---@field public StyleVar_SelectableTextAlign integer @// ImVec2    SelectableTextAlign
---@field public StyleVar_COUNT integer 
---@field public ButtonFlags_None integer 
---@field public ButtonFlags_MouseButtonLeft integer @// React on left mouse button (default)
---@field public ButtonFlags_MouseButtonRight integer @// React on right mouse button
---@field public ButtonFlags_MouseButtonMiddle integer @// React on center mouse button
---@field public ButtonFlags_MouseButtonMask_ integer 
---@field public ButtonFlags_MouseButtonDefault_ integer 
---@field public ColorEditFlags_None integer 
---@field public ColorEditFlags_NoAlpha integer @//              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer).
---@field public ColorEditFlags_NoPicker integer @//              // ColorEdit: disable picker when clicking on color square.
---@field public ColorEditFlags_NoOptions integer @//              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.
---@field public ColorEditFlags_NoSmallPreview integer @//              // ColorEdit, ColorPicker: disable color square preview next to the inputs. (e.g. to show only the inputs)
---@field public ColorEditFlags_NoInputs integer @//              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
---@field public ColorEditFlags_NoTooltip integer @//              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.
---@field public ColorEditFlags_NoLabel integer @//              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).
---@field public ColorEditFlags_NoSidePreview integer @//              // ColorPicker: disable bigger color preview on right side of the picker, use small color square preview instead.
---@field public ColorEditFlags_NoDragDrop integer @//              // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.
---@field public ColorEditFlags_NoBorder integer @//              // ColorButton: disable border (which is enforced by default)
---@field public ColorEditFlags_AlphaBar integer @//              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.
---@field public ColorEditFlags_AlphaPreview integer @//              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.
---@field public ColorEditFlags_AlphaPreviewHalf integer @//              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.
---@field public ColorEditFlags_HDR integer @//              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).
---@field public ColorEditFlags_DisplayRGB integer @// [Display]    // ColorEdit: override _display_ type among RGB/HSV/Hex. ColorPicker: select any combination using one or more of RGB/HSV/Hex.
---@field public ColorEditFlags_DisplayHSV integer @// [Display]    // "
---@field public ColorEditFlags_DisplayHex integer @// [Display]    // "
---@field public ColorEditFlags_Uint8 integer @// [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.
---@field public ColorEditFlags_Float integer @// [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.
---@field public ColorEditFlags_PickerHueBar integer @// [Picker]     // ColorPicker: bar for Hue, rectangle for Sat/Value.
---@field public ColorEditFlags_PickerHueWheel integer @// [Picker]     // ColorPicker: wheel for Hue, triangle for Sat/Value.
---@field public ColorEditFlags_InputRGB integer @// [Input]      // ColorEdit, ColorPicker: input and output data in RGB format.
---@field public ColorEditFlags_InputHSV integer @// [Input]      // ColorEdit, ColorPicker: input and output data in HSV format.
---@field public ColorEditFlags_DefaultOptions_ integer 
---@field public ColorEditFlags_DisplayMask_ integer 
---@field public ColorEditFlags_DataTypeMask_ integer 
---@field public ColorEditFlags_PickerMask_ integer 
---@field public ColorEditFlags_InputMask_ integer 
---@field public SliderFlags_None integer 
---@field public SliderFlags_AlwaysClamp integer @// Clamp value to min/max bounds when input manually with CTRL+Click. By default CTRL+Click allows going out of bounds.
---@field public SliderFlags_Logarithmic integer @// Make the widget logarithmic (linear otherwise). Consider using ImGuiSliderFlags_NoRoundToFormat with this if using a format-string with small amount of digits.
---@field public SliderFlags_NoRoundToFormat integer @// Disable rounding underlying value to match precision of the display format string (e.g. %.3f values are rounded to those 3 digits)
---@field public SliderFlags_NoInput integer @// Disable CTRL+Click or Enter key allowing to input text directly into the widget
---@field public SliderFlags_InvalidMask_ integer @// [Internal] We treat using those bits as being potentially a 'float power' argument from the previous API that has got miscast to this enum, and will trigger an assert if needed.
---@field public SliderFlags_ClampOnInput integer @// [renamed in 1.79]
---@field public MouseButton_Left integer 
---@field public MouseButton_Right integer 
---@field public MouseButton_Middle integer 
---@field public MouseButton_COUNT integer 
---@field public MouseCursor_None integer 
---@field public MouseCursor_Arrow integer 
---@field public MouseCursor_TextInput integer @// When hovering over InputText, etc.
---@field public MouseCursor_ResizeAll integer @// (Unused by Dear ImGui functions)
---@field public MouseCursor_ResizeNS integer @// When hovering over an horizontal border
---@field public MouseCursor_ResizeEW integer @// When hovering over a vertical border or a column
---@field public MouseCursor_ResizeNESW integer @// When hovering over the bottom-left corner of a window
---@field public MouseCursor_ResizeNWSE integer @// When hovering over the bottom-right corner of a window
---@field public MouseCursor_Hand integer @// (Unused by Dear ImGui functions. Use for e.g. hyperlinks)
---@field public MouseCursor_NotAllowed integer @// When hovering something with disallowed interaction. Usually a crossed circle.
---@field public MouseCursor_COUNT integer 
---@field public Cond_None integer @// No condition (always set the variable), same as _Always
---@field public Cond_Always integer @// No condition (always set the variable), same as _None
---@field public Cond_Once integer @// Set the variable once per runtime session (only the first call will succeed)
---@field public Cond_FirstUseEver integer @// Set the variable if the object/window has no persistently saved data (no entry in .ini file)
---@field public Cond_Appearing integer @// Set the variable if the object/window is appearing after being hidden/inactive (or the first time)
---@field public ImDrawFlags_None integer 
---@field public ImDrawFlags_Closed integer @// PathStroke(), AddPolyline(): specify that shape should be closed (Important: this is always == 1 for legacy reason)
---@field public ImDrawFlags_RoundCornersTopLeft integer @// AddRect(), AddRectFilled(), PathRect(): enable rounding top-left corner only (when rounding > 0.0f, we default to all corners). Was 0x01.
---@field public ImDrawFlags_RoundCornersTopRight integer @// AddRect(), AddRectFilled(), PathRect(): enable rounding top-right corner only (when rounding > 0.0f, we default to all corners). Was 0x02.
---@field public ImDrawFlags_RoundCornersBottomLeft integer @// AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-left corner only (when rounding > 0.0f, we default to all corners). Was 0x04.
---@field public ImDrawFlags_RoundCornersBottomRight integer @// AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-right corner only (when rounding > 0.0f, we default to all corners). Wax 0x08.
---@field public ImDrawFlags_RoundCornersNone integer @// AddRect(), AddRectFilled(), PathRect(): disable rounding on all corners (when rounding > 0.0f). This is NOT zero, NOT an implicit flag!
---@field public ImDrawFlags_RoundCornersTop integer 
---@field public ImDrawFlags_RoundCornersBottom integer 
---@field public ImDrawFlags_RoundCornersLeft integer 
---@field public ImDrawFlags_RoundCornersRight integer 
---@field public ImDrawFlags_RoundCornersAll integer 
---@field public ImDrawFlags_RoundCornersDefault_ integer @// Default to ALL corners if none of the _RoundCornersXX flags are specified.
---@field public ImDrawFlags_RoundCornersMask_ integer 
---@field public ImDrawListFlags_None integer 
---@field public ImDrawListFlags_AntiAliasedLines integer @// Enable anti-aliased lines/borders (*2 the number of triangles for 1.0f wide line or lines thin enough to be drawn using textures, otherwise *3 the number of triangles)
---@field public ImDrawListFlags_AntiAliasedLinesUseTex integer @// Enable anti-aliased lines/borders using textures when possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).
---@field public ImDrawListFlags_AntiAliasedFill integer @// Enable anti-aliased edge around filled shapes (rounded rectangles, circles).
---@field public ImDrawListFlags_AllowVtxOffset integer @// Can emit 'VtxOffset > 0' to allow large meshes. Set when 'ImGuiBackendFlags_RendererHasVtxOffset' is enabled.
---@field public ImFontAtlasFlags_None integer 
---@field public ImFontAtlasFlags_NoPowerOfTwoHeight integer @// Don't round the height to next power of two
---@field public ImFontAtlasFlags_NoMouseCursors integer @// Don't build software mouse cursors into the atlas (save a little texture memory)
---@field public ImFontAtlasFlags_NoBakedLines integer @// Don't build thick line textures into the atlas (save a little texture memory, allow support for point/nearest filtering). The AntiAliasedLinesUseTex features uses them, otherwise they will be rendered using polygons (more expensive for CPU/GPU).
---@field public ViewportFlags_None integer 
---@field public ViewportFlags_IsPlatformWindow integer @// Represent a Platform Window
---@field public ViewportFlags_IsPlatformMonitor integer @// Represent a Platform Monitor (unused yet)
---@field public ViewportFlags_OwnedByApp integer @// Platform Window: is created/managed by the application (rather than a dear imgui backend)
---@field public ViewportFlags_NoDecoration integer @// Platform Window: Disable platform decorations: title bar, borders, etc. (generally set all windows, but if ImGuiConfigFlags_ViewportsDecoration is set we only set this on popups/tooltips)
---@field public ViewportFlags_NoTaskBarIcon integer @// Platform Window: Disable platform task bar icon (generally set on popups/tooltips, or all windows if ImGuiConfigFlags_ViewportsNoTaskBarIcon is set)
---@field public ViewportFlags_NoFocusOnAppearing integer @// Platform Window: Don't take focus when created.
---@field public ViewportFlags_NoFocusOnClick integer @// Platform Window: Don't take focus when clicked on.
---@field public ViewportFlags_NoInputs integer @// Platform Window: Make mouse pass through so we can drag this window while peaking behind it.
---@field public ViewportFlags_NoRendererClear integer @// Platform Window: Renderer doesn't need to clear the framebuffer ahead (because we will fill it entirely).
---@field public ViewportFlags_TopMost integer @// Platform Window: Display on top (for tooltips only).
---@field public ViewportFlags_Minimized integer @// Platform Window: Window is minimized, can skip render. When minimized we tend to avoid using the viewport pos/size for clipping window or testing if they are contained in the viewport.
---@field public ViewportFlags_NoAutoMerge integer @// Platform Window: Avoid merging this window into another host window. This can only be set via ImGuiWindowClass viewport flags override (because we need to now ahead if we are going to create a viewport in the first place!).
---@field public ViewportFlags_CanHostOtherWindows integer @// Main viewport: can host multiple imgui windows (secondary viewports are associated to a single window).
---@field public ImDrawCornerFlags_None integer @// Was == 0 prior to 1.82, this is now == ImDrawFlags_RoundCornersNone which is != 0 and not implicit
---@field public ImDrawCornerFlags_TopLeft integer @// Was == 0x01 (1 << 0) prior to 1.82. Order matches ImDrawFlags_NoRoundCorner* flag (we exploit this internally).
---@field public ImDrawCornerFlags_TopRight integer @// Was == 0x02 (1 << 1) prior to 1.82.
---@field public ImDrawCornerFlags_BotLeft integer @// Was == 0x04 (1 << 2) prior to 1.82.
---@field public ImDrawCornerFlags_BotRight integer @// Was == 0x08 (1 << 3) prior to 1.82.
---@field public ImDrawCornerFlags_All integer @// Was == 0x0F prior to 1.82
---@field public ImDrawCornerFlags_Top integer 
---@field public ImDrawCornerFlags_Bot integer 
---@field public ImDrawCornerFlags_Left integer 
---@field public ImDrawCornerFlags_Right integer 
---@field public KeyModFlags_None integer 
---@field public KeyModFlags_Ctrl integer 
---@field public KeyModFlags_Shift integer 
---@field public KeyModFlags_Alt integer 
---@field public KeyModFlags_Super integer 
local _imgui = {}


--- Context creation and access
--- - Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between contexts.
--- - DLL users: heaps and globals are not shared across DLL boundaries! You will need to call SetCurrentContext() + SetAllocatorFunctions()
---   for each static/DLL boundary you are calling from. Read "Context and Memory Allocators" section of imgui.cpp for details.
---@param shared_font_atlas ImFontAtlas*
---@return ImGuiContext*
function _imgui.CreateContext(shared_font_atlas) end


--- NULL = destroy current context
---@param ctx ImGuiContext*
---@return void
function _imgui.DestroyContext(ctx) end


---@return ImGuiContext*
function _imgui.GetCurrentContext() end


---@param ctx ImGuiContext*
---@return void
function _imgui.SetCurrentContext(ctx) end

--- Main
--- access the IO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)
---@return ImGuiIO*
function _imgui.GetIO() end


--- access the Style structure (colors, sizes). Always use PushStyleCol(), PushStyleVar() to modify style mid-frame!
---@return ImGuiStyle*
function _imgui.GetStyle() end


--- start a new Dear ImGui frame, you can submit any command from this point until Render()/EndFrame().
---@return void
function _imgui.NewFrame() end


--- ends the Dear ImGui frame. automatically called by Render(). If you don't need to render data (skipping rendering) you may call EndFrame() without Render()... but you'll have wasted CPU already! If you don't need to render, better to not create any windows and not call NewFrame() at all!
---@return void
function _imgui.EndFrame() end


--- ends the Dear ImGui frame, finalize the draw data. You can then get call GetDrawData().
---@return void
function _imgui.Render() end


--- valid after Render() and until the next call to NewFrame(). this is what you have to render.
---@return ImDrawData*
function _imgui.GetDrawData() end

--- Demo, Debug, Information
--- create Demo window. demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!
---@param p_open bool*
---@return void
function _imgui.ShowDemoWindow(p_open) end


--- create Metrics/Debugger window. display Dear ImGui internals: windows, draw commands, various internal state, etc.
---@param p_open bool*
---@return void
function _imgui.ShowMetricsWindow(p_open) end


--- create Debug Log window. display a simplified log of important dear imgui events.
---@param p_open bool*
---@return void
function _imgui.ShowDebugLogWindow(p_open) end


--- create Stack Tool window. hover items with mouse to query information about the source of their unique ID.
---@param p_open bool*
---@return void
function _imgui.ShowStackToolWindow(p_open) end


--- create About window. display Dear ImGui version, credits and build/system information.
---@param p_open bool*
---@return void
function _imgui.ShowAboutWindow(p_open) end


--- add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)
---@param ref ImGuiStyle*
---@return void
function _imgui.ShowStyleEditor(ref) end


--- add style selector block (not a window), essentially a combo listing the default styles.
---@param label const char*
---@return bool
function _imgui.ShowStyleSelector(label) end


--- add font selector block (not a window), essentially a combo listing the loaded fonts.
---@param label const char*
---@return void
function _imgui.ShowFontSelector(label) end


--- add basic help/info block (not a window): how to manipulate ImGui as a end-user (mouse/keyboard controls).
---@return void
function _imgui.ShowUserGuide() end


--- get the compiled version string e.g. "1.80 WIP" (essentially the value for IMGUI_VERSION from the compiled version of imgui.cpp)
---@return const char*
function _imgui.GetVersion() end

--- Styles
--- new, recommended style (default)
---@param dst ImGuiStyle*
---@return void
function _imgui.StyleColorsDark(dst) end


--- best used with borders and a custom, thicker font
---@param dst ImGuiStyle*
---@return void
function _imgui.StyleColorsLight(dst) end


--- classic imgui style
---@param dst ImGuiStyle*
---@return void
function _imgui.StyleColorsClassic(dst) end

--- Windows
--- - Begin() = push window to the stack and start appending to it. End() = pop window from the stack.
--- - Passing 'bool* p_open != NULL' shows a window-closing widget in the upper-right corner of the window,
---   which clicking will set the boolean to false when clicked.
--- - You may append multiple times to the same window during the same frame by calling Begin()/End() pairs multiple times.
---   Some information such as 'flags' or 'p_open' will only be considered by the first call to Begin().
--- - Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting
---   anything to the window. Always call a matching End() for each Begin() call, regardless of its return value!
---   [Important: due to legacy reason, this is inconsistent with most other functions such as BeginMenu/EndMenu,
---    BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding BeginXXX function
---    returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.]
--- - Note that the bottom of window stack always contains a window called "Debug".
---@param name const char*
---@param p_open bool*
---@param flags ImGuiWindowFlags
---@return bool
function _imgui.Begin(name, p_open, flags) end


---@return void
function _imgui.End() end

--- Child Windows
--- - Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child.
--- - For each independent axis of 'size': ==0.0f: use remaining host window size / >0.0f: fixed size / <0.0f: use remaining window size minus abs(size) / Each axis can use a different mode, e.g. ImVec2(0,400).
--- - BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window.
---   Always call a matching EndChild() for each BeginChild() call, regardless of its return value.
---   [Important: due to legacy reason, this is inconsistent with most other functions such as BeginMenu/EndMenu,
---    BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding BeginXXX function
---    returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.]
---@param str_id const char*
---@param size ImVec2
---@param border bool
---@param flags ImGuiWindowFlags
---@return bool
function _imgui.BeginChild(str_id, size, border, flags) end


---@param id ImGuiID
---@param size ImVec2
---@param border bool
---@param flags ImGuiWindowFlags
---@return bool
function _imgui.BeginChildID(id, size, border, flags) end


---@return void
function _imgui.EndChild() end

--- Windows Utilities
--- - 'current window' = the window we are appending into while inside a Begin()/End() block. 'next window' = next window we will Begin() into.
---@return bool
function _imgui.IsWindowAppearing() end


---@return bool
function _imgui.IsWindowCollapsed() end


--- is current window focused? or its root/child, depending on flags. see flags for options.
---@param flags ImGuiFocusedFlags
---@return bool
function _imgui.IsWindowFocused(flags) end


--- is current window hovered (and typically: not blocked by a popup/modal)? see flags for options. NB: If you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that! Please read the FAQ!
---@param flags ImGuiHoveredFlags
---@return bool
function _imgui.IsWindowHovered(flags) end


--- get draw list associated to the current window, to append your own drawing primitives
---@return ImDrawList*
function _imgui.GetWindowDrawList() end


--- get DPI scale currently associated to the current window's viewport.
---@return float
function _imgui.GetWindowDpiScale() end


--- get current window position in screen space (useful if you want to do your own drawing via the DrawList API)
---@return ImVec2
function _imgui.GetWindowPos() end


--- get current window size
---@return ImVec2
function _imgui.GetWindowSize() end


--- get current window width (shortcut for GetWindowSize().x)
---@return float
function _imgui.GetWindowWidth() end


--- get current window height (shortcut for GetWindowSize().y)
---@return float
function _imgui.GetWindowHeight() end


--- get viewport currently associated to the current window.
---@return ImGuiViewport*
function _imgui.GetWindowViewport() end

--- Window manipulation
--- - Prefer using SetNextXXX functions (before Begin) rather that SetXXX functions (after Begin).
--- Implied pivot = ImVec2(0, 0)
---@param pos ImVec2
---@param cond ImGuiCond
---@return void
function _imgui.SetNextWindowPos(pos, cond) end


--- set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.
---@param pos ImVec2
---@param cond ImGuiCond
---@param pivot ImVec2
---@return void
function _imgui.SetNextWindowPosEx(pos, cond, pivot) end


--- set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()
---@param size ImVec2
---@param cond ImGuiCond
---@return void
function _imgui.SetNextWindowSize(size, cond) end


--- set next window size limits. use -1,-1 on either X/Y axis to preserve the current size. Sizes will be rounded down. Use callback to apply non-trivial programmatic constraints.
---@param size_min ImVec2
---@param size_max ImVec2
---@param custom_callback ImGuiSizeCallback
---@param custom_callback_data void*
---@return void
function _imgui.SetNextWindowSizeConstraints(size_min, size_max, custom_callback, custom_callback_data) end


--- set next window content size (~ scrollable client area, which enforce the range of scrollbars). Not including window decorations (title bar, menu bar, etc.) nor WindowPadding. set an axis to 0.0f to leave it automatic. call before Begin()
---@param size ImVec2
---@return void
function _imgui.SetNextWindowContentSize(size) end


--- set next window collapsed state. call before Begin()
---@param collapsed bool
---@param cond ImGuiCond
---@return void
function _imgui.SetNextWindowCollapsed(collapsed, cond) end


--- set next window to be focused / top-most. call before Begin()
---@return void
function _imgui.SetNextWindowFocus() end


--- set next window background color alpha. helper to easily override the Alpha component of ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.
---@param alpha float
---@return void
function _imgui.SetNextWindowBgAlpha(alpha) end


--- set next window viewport
---@param viewport_id ImGuiID
---@return void
function _imgui.SetNextWindowViewport(viewport_id) end


--- (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
---@param pos ImVec2
---@param cond ImGuiCond
---@return void
function _imgui.SetWindowPos(pos, cond) end


--- (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
---@param size ImVec2
---@param cond ImGuiCond
---@return void
function _imgui.SetWindowSize(size, cond) end


--- (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
---@param collapsed bool
---@param cond ImGuiCond
---@return void
function _imgui.SetWindowCollapsed(collapsed, cond) end


--- (not recommended) set current window to be focused / top-most. prefer using SetNextWindowFocus().
---@return void
function _imgui.SetWindowFocus() end


--- [OBSOLETE] set font scale. Adjust IO.FontGlobalScale if you want to scale all windows. This is an old API! For correct scaling, prefer to reload font + rebuild ImFontAtlas + call style.ScaleAllSizes().
---@param scale float
---@return void
function _imgui.SetWindowFontScale(scale) end


--- set named window position.
---@param name const char*
---@param pos ImVec2
---@param cond ImGuiCond
---@return void
function _imgui.SetWindowPosStr(name, pos, cond) end


--- set named window size. set axis to 0.0f to force an auto-fit on this axis.
---@param name const char*
---@param size ImVec2
---@param cond ImGuiCond
---@return void
function _imgui.SetWindowSizeStr(name, size, cond) end


--- set named window collapsed state
---@param name const char*
---@param collapsed bool
---@param cond ImGuiCond
---@return void
function _imgui.SetWindowCollapsedStr(name, collapsed, cond) end


--- set named window to be focused / top-most. use NULL to remove focus.
---@param name const char*
---@return void
function _imgui.SetWindowFocusStr(name) end

--- Content region
--- - Retrieve available space from a given point. GetContentRegionAvail() is frequently useful.
--- - Those functions are bound to be redesigned (they are confusing, incomplete and the Min/Max return values are in local window coordinates which increases confusion)
--- == GetContentRegionMax() - GetCursorPos()
---@return ImVec2
function _imgui.GetContentRegionAvail() end


--- current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates
---@return ImVec2
function _imgui.GetContentRegionMax() end


--- content boundaries min for the full window (roughly (0,0)-Scroll), in window coordinates
---@return ImVec2
function _imgui.GetWindowContentRegionMin() end


--- content boundaries max for the full window (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates
---@return ImVec2
function _imgui.GetWindowContentRegionMax() end

--- Windows Scrolling
--- get scrolling amount [0 .. GetScrollMaxX()]
---@return float
function _imgui.GetScrollX() end


--- get scrolling amount [0 .. GetScrollMaxY()]
---@return float
function _imgui.GetScrollY() end


--- set scrolling amount [0 .. GetScrollMaxX()]
---@param scroll_x float
---@return void
function _imgui.SetScrollX(scroll_x) end


--- set scrolling amount [0 .. GetScrollMaxY()]
---@param scroll_y float
---@return void
function _imgui.SetScrollY(scroll_y) end


--- get maximum scrolling amount ~~ ContentSize.x - WindowSize.x - DecorationsSize.x
---@return float
function _imgui.GetScrollMaxX() end


--- get maximum scrolling amount ~~ ContentSize.y - WindowSize.y - DecorationsSize.y
---@return float
function _imgui.GetScrollMaxY() end


--- adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
---@param center_x_ratio float
---@return void
function _imgui.SetScrollHereX(center_x_ratio) end


--- adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
---@param center_y_ratio float
---@return void
function _imgui.SetScrollHereY(center_y_ratio) end


--- adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
---@param local_x float
---@param center_x_ratio float
---@return void
function _imgui.SetScrollFromPosX(local_x, center_x_ratio) end


--- adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
---@param local_y float
---@param center_y_ratio float
---@return void
function _imgui.SetScrollFromPosY(local_y, center_y_ratio) end

--- Parameters stacks (shared)
--- use NULL as a shortcut to push default font
---@param font ImFont*
---@return void
function _imgui.PushFont(font) end


---@return void
function _imgui.PopFont() end


--- modify a style color. always use this if you modify the style after NewFrame().
---@param idx ImGuiCol
---@param col ImU32
---@return void
function _imgui.PushStyleColor(idx, col) end


---@param idx ImGuiCol
---@param col ImVec4
---@return void
function _imgui.PushStyleColorImVec4(idx, col) end


--- Implied count = 1
---@return void
function _imgui.PopStyleColor() end


---@param count int
---@return void
function _imgui.PopStyleColorEx(count) end


--- modify a style float variable. always use this if you modify the style after NewFrame().
---@param idx ImGuiStyleVar
---@param val float
---@return void
function _imgui.PushStyleVar(idx, val) end


--- modify a style ImVec2 variable. always use this if you modify the style after NewFrame().
---@param idx ImGuiStyleVar
---@param val ImVec2
---@return void
function _imgui.PushStyleVarImVec2(idx, val) end


--- Implied count = 1
---@return void
function _imgui.PopStyleVar() end


---@param count int
---@return void
function _imgui.PopStyleVarEx(count) end


--- == tab stop enable. Allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets
---@param allow_keyboard_focus bool
---@return void
function _imgui.PushAllowKeyboardFocus(allow_keyboard_focus) end


---@return void
function _imgui.PopAllowKeyboardFocus() end


--- in 'repeat' mode, Button*() functions return repeated true in a typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.
---@param repeat_ bool
---@return void
function _imgui.PushButtonRepeat(repeat_) end


---@return void
function _imgui.PopButtonRepeat() end

--- Parameters stacks (current window)
--- push width of items for common large "item+label" widgets. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side).
---@param item_width float
---@return void
function _imgui.PushItemWidth(item_width) end


---@return void
function _imgui.PopItemWidth() end


--- set width of the _next_ common large "item+label" widget. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side)
---@param item_width float
---@return void
function _imgui.SetNextItemWidth(item_width) end


--- width of item given pushed settings and current cursor position. NOT necessarily the width of last item unlike most 'Item' functions.
---@return float
function _imgui.CalcItemWidth() end


--- push word-wrapping position for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space
---@param wrap_local_pos_x float
---@return void
function _imgui.PushTextWrapPos(wrap_local_pos_x) end


---@return void
function _imgui.PopTextWrapPos() end

--- Style read access
--- - Use the style editor (ShowStyleEditor() function) to interactively see what the colors are)
--- get current font
---@return ImFont*
function _imgui.GetFont() end


--- get current font size (= height in pixels) of current font with current scale applied
---@return float
function _imgui.GetFontSize() end


--- get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API
---@return ImVec2
function _imgui.GetFontTexUvWhitePixel() end


--- Implied alpha_mul = 1.0f
---@param idx ImGuiCol
---@return ImU32
function _imgui.GetColorU32(idx) end


--- retrieve given style color with style alpha applied and optional extra alpha multiplier, packed as a 32-bit value suitable for ImDrawList
---@param idx ImGuiCol
---@param alpha_mul float
---@return ImU32
function _imgui.GetColorU32Ex(idx, alpha_mul) end


--- retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList
---@param col ImVec4
---@return ImU32
function _imgui.GetColorU32ImVec4(col) end


--- retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList
---@param col ImU32
---@return ImU32
function _imgui.GetColorU32ImU32(col) end


--- retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwise use GetColorU32() to get style color with style alpha baked in.
---@param idx ImGuiCol
---@return const ImVec4*
function _imgui.GetStyleColorVec4(idx) end

--- Cursor / Layout
--- - By "cursor" we mean the current output position.
--- - The typical widget behavior is to output themselves at the current cursor position, then move the cursor one line down.
--- - You can call SameLine() between widgets to undo the last carriage return and output at the right of the preceding widget.
--- - Attention! We currently have inconsistencies between window-local and absolute positions we will aim to fix with future API:
---    Window-local coordinates:   SameLine(), GetCursorPos(), SetCursorPos(), GetCursorStartPos(), GetContentRegionMax(), GetWindowContentRegion*(), PushTextWrapPos()
---    Absolute coordinate:        GetCursorScreenPos(), SetCursorScreenPos(), all ImDrawList:: functions.
--- separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.
---@return void
function _imgui.Separator() end


--- Implied offset_from_start_x = 0.0f, spacing = -1.0f
---@return void
function _imgui.SameLine() end


--- call between widgets or groups to layout them horizontally. X position given in window coordinates.
---@param offset_from_start_x float
---@param spacing float
---@return void
function _imgui.SameLineEx(offset_from_start_x, spacing) end


--- undo a SameLine() or force a new line when in an horizontal-layout context.
---@return void
function _imgui.NewLine() end


--- add vertical spacing.
---@return void
function _imgui.Spacing() end


--- add a dummy item of given size. unlike InvisibleButton(), Dummy() won't take the mouse click or be navigable into.
---@param size ImVec2
---@return void
function _imgui.Dummy(size) end


--- Implied indent_w = 0.0f
---@return void
function _imgui.Indent() end


--- move content position toward the right, by indent_w, or style.IndentSpacing if indent_w <= 0
---@param indent_w float
---@return void
function _imgui.IndentEx(indent_w) end


--- Implied indent_w = 0.0f
---@return void
function _imgui.Unindent() end


--- move content position back to the left, by indent_w, or style.IndentSpacing if indent_w <= 0
---@param indent_w float
---@return void
function _imgui.UnindentEx(indent_w) end


--- lock horizontal starting position
---@return void
function _imgui.BeginGroup() end


--- unlock horizontal starting position + capture the whole group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
---@return void
function _imgui.EndGroup() end


--- cursor position in window coordinates (relative to window position)
---@return ImVec2
function _imgui.GetCursorPos() end


---   (some functions are using window-relative coordinates, such as: GetCursorPos, GetCursorStartPos, GetContentRegionMax, GetWindowContentRegion* etc.
---@return float
function _imgui.GetCursorPosX() end


---    other functions such as GetCursorScreenPos or everything in ImDrawList::
---@return float
function _imgui.GetCursorPosY() end


---    are using the main, absolute coordinate system.
---@param local_pos ImVec2
---@return void
function _imgui.SetCursorPos(local_pos) end


---    GetWindowPos() + GetCursorPos() == GetCursorScreenPos() etc.)
---@param local_x float
---@return void
function _imgui.SetCursorPosX(local_x) end


---
---@param local_y float
---@return void
function _imgui.SetCursorPosY(local_y) end


--- initial cursor position in window coordinates
---@return ImVec2
function _imgui.GetCursorStartPos() end


--- cursor position in absolute coordinates (useful to work with ImDrawList API). generally top-left == GetMainViewport()->Pos == (0,0) in single viewport mode, and bottom-right == GetMainViewport()->Pos+Size == io.DisplaySize in single-viewport mode.
---@return ImVec2
function _imgui.GetCursorScreenPos() end


--- cursor position in absolute coordinates
---@param pos ImVec2
---@return void
function _imgui.SetCursorScreenPos(pos) end


--- vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)
---@return void
function _imgui.AlignTextToFramePadding() end


--- ~ FontSize
---@return float
function _imgui.GetTextLineHeight() end


--- ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)
---@return float
function _imgui.GetTextLineHeightWithSpacing() end


--- ~ FontSize + style.FramePadding.y * 2
---@return float
function _imgui.GetFrameHeight() end


--- ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)
---@return float
function _imgui.GetFrameHeightWithSpacing() end

--- ID stack/scopes
--- Read the FAQ (docs/FAQ.md or http:---dearimgui.org/faq) for more details about how ID are handled in dear imgui.
--- - Those questions are answered and impacted by understanding of the ID stack system:
---   - "Q: Why is my widget not reacting when I click on it?"
---   - "Q: How can I have widgets with an empty label?"
---   - "Q: How can I have multiple widgets with the same label?"
--- - Short version: ID are hashes of the entire ID stack. If you are creating widgets in a loop you most likely
---   want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.
--- - You can also use the "Label##foobar" syntax within widget label to distinguish them from each others.
--- - In this header file we use the "label"/"name" terminology to denote a string that will be displayed + used as an ID,
---   whereas "str_id" denote a string that is only used as an ID and not normally displayed.
--- push string into the ID stack (will hash string).
---@param str_id const char*
---@return void
function _imgui.PushID(str_id) end


--- push string into the ID stack (will hash string).
---@param str_id_begin const char*
---@param str_id_end const char*
---@return void
function _imgui.PushIDStr(str_id_begin, str_id_end) end


--- push pointer into the ID stack (will hash pointer).
---@param ptr_id const void*
---@return void
function _imgui.PushIDPtr(ptr_id) end


--- push integer into the ID stack (will hash integer).
---@param int_id int
---@return void
function _imgui.PushIDInt(int_id) end


--- pop from the ID stack.
---@return void
function _imgui.PopID() end


--- calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
---@param str_id const char*
---@return ImGuiID
function _imgui.GetID(str_id) end


---@param str_id_begin const char*
---@param str_id_end const char*
---@return ImGuiID
function _imgui.GetIDStr(str_id_begin, str_id_end) end


---@param ptr_id const void*
---@return ImGuiID
function _imgui.GetIDPtr(ptr_id) end

--- Widgets: Text
--- Implied text_end = NULL
---@param text const char*
---@return void
function _imgui.TextUnformatted(text) end


--- raw text without formatting. Roughly equivalent to Text("%s", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text.
---@param text const char*
---@param text_end const char*
---@return void
function _imgui.TextUnformattedEx(text, text_end) end


--- formatted text
---@param fmt const char*
---@return void
function _imgui.Text(fmt, ...) end


---@param fmt const char*
---@param args va_list
---@return void
function _imgui.TextV(fmt, args) end


--- shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();
---@param col ImVec4
---@param fmt const char*
---@return void
function _imgui.TextColored(col, fmt, ...) end


---@param col ImVec4
---@param fmt const char*
---@param args va_list
---@return void
function _imgui.TextColoredV(col, fmt, args) end


--- shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();
---@param fmt const char*
---@return void
function _imgui.TextDisabled(fmt, ...) end


---@param fmt const char*
---@param args va_list
---@return void
function _imgui.TextDisabledV(fmt, args) end


--- shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().
---@param fmt const char*
---@return void
function _imgui.TextWrapped(fmt, ...) end


---@param fmt const char*
---@param args va_list
---@return void
function _imgui.TextWrappedV(fmt, args) end


--- display text+label aligned the same way as value+label widgets
---@param label const char*
---@param fmt const char*
---@return void
function _imgui.LabelText(label, fmt, ...) end


---@param label const char*
---@param fmt const char*
---@param args va_list
---@return void
function _imgui.LabelTextV(label, fmt, args) end


--- shortcut for Bullet()+Text()
---@param fmt const char*
---@return void
function _imgui.BulletText(fmt, ...) end


---@param fmt const char*
---@param args va_list
---@return void
function _imgui.BulletTextV(fmt, args) end

--- Widgets: Main
--- - Most widgets return true when the value has been changed or when pressed/selected
--- - You may also use one of the many IsItemXXX functions (e.g. IsItemActive, IsItemHovered, etc.) to query widget state.
--- Implied size = ImVec2(0, 0)
---@param label const char*
---@return bool
function _imgui.Button(label) end


--- button
---@param label const char*
---@param size ImVec2
---@return bool
function _imgui.ButtonEx(label, size) end


--- button with FramePadding=(0,0) to easily embed within text
---@param label const char*
---@return bool
function _imgui.SmallButton(label) end


--- flexible button behavior without the visuals, frequently useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.)
---@param str_id const char*
---@param size ImVec2
---@param flags ImGuiButtonFlags
---@return bool
function _imgui.InvisibleButton(str_id, size, flags) end


--- square button with an arrow shape
---@param str_id const char*
---@param dir ImGuiDir
---@return bool
function _imgui.ArrowButton(str_id, dir) end


---@param label const char*
---@param v bool*
---@return bool
function _imgui.Checkbox(label, v) end


---@param label const char*
---@param flags int*
---@param flags_value int
---@return bool
function _imgui.CheckboxFlagsIntPtr(label, flags, flags_value) end


---@param label const char*
---@param flags unsigned int*
---@param flags_value unsigned int
---@return bool
function _imgui.CheckboxFlagsUintPtr(label, flags, flags_value) end


--- use with e.g. if (RadioButton("one", my_value==1)) { my_value = 1; }
---@param label const char*
---@param active bool
---@return bool
function _imgui.RadioButton(label, active) end


--- shortcut to handle the above pattern when value is an integer
---@param label const char*
---@param v int*
---@param v_button int
---@return bool
function _imgui.RadioButtonIntPtr(label, v, v_button) end


---@param fraction float
---@param size_arg ImVec2
---@param overlay const char*
---@return void
function _imgui.ProgressBar(fraction, size_arg, overlay) end


--- draw a small circle + keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses
---@return void
function _imgui.Bullet() end

--- Widgets: Images
--- - Read about ImTextureID here: https:---github.com/ocornut/imgui/wiki/Image-Loading-and-Displaying-Examples
--- Implied uv0 = ImVec2(0, 0), uv1 = ImVec2(1, 1), tint_col = ImVec4(1, 1, 1, 1), border_col = ImVec4(0, 0, 0, 0)
---@param user_texture_id ImTextureID
---@param size ImVec2
---@return void
function _imgui.Image(user_texture_id, size) end


---@param user_texture_id ImTextureID
---@param size ImVec2
---@param uv0 ImVec2
---@param uv1 ImVec2
---@param tint_col ImVec4
---@param border_col ImVec4
---@return void
function _imgui.ImageEx(user_texture_id, size, uv0, uv1, tint_col, border_col) end


--- Implied uv0 = ImVec2(0, 0), uv1 = ImVec2(1, 1), bg_col = ImVec4(0, 0, 0, 0), tint_col = ImVec4(1, 1, 1, 1)
---@param str_id const char*
---@param user_texture_id ImTextureID
---@param size ImVec2
---@return bool
function _imgui.ImageButton(str_id, user_texture_id, size) end


---@param str_id const char*
---@param user_texture_id ImTextureID
---@param size ImVec2
---@param uv0 ImVec2
---@param uv1 ImVec2
---@param bg_col ImVec4
---@param tint_col ImVec4
---@return bool
function _imgui.ImageButtonEx(str_id, user_texture_id, size, uv0, uv1, bg_col, tint_col) end

--- Widgets: Combo Box
--- - The BeginCombo()/EndCombo() api allows you to manage your contents and selection state however you want it, by creating e.g. Selectable() items.
--- - The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept available for convenience purpose. This is analogous to how ListBox are created.
---@param label const char*
---@param preview_value const char*
---@param flags ImGuiComboFlags
---@return bool
function _imgui.BeginCombo(label, preview_value, flags) end


--- only call EndCombo() if BeginCombo() returns true!
---@return void
function _imgui.EndCombo() end


--- Implied popup_max_height_in_items = -1
---@param label const char*
---@param current_item int*
---@param items const char*const
---@param items_count int
---@return bool
function _imgui.ComboChar(label, current_item, items, items_count) end


---@param label const char*
---@param current_item int*
---@param items const char*const
---@param items_count int
---@param popup_max_height_in_items int
---@return bool
function _imgui.ComboCharEx(label, current_item, items, items_count, popup_max_height_in_items) end


--- Implied popup_max_height_in_items = -1
---@param label const char*
---@param current_item int*
---@param items_separated_by_zeros const char*
---@return bool
function _imgui.Combo(label, current_item, items_separated_by_zeros) end


--- Separate items with \0 within a string, end item-list with \0\0. e.g. "One\0Two\0Three\0"
---@param label const char*
---@param current_item int*
---@param items_separated_by_zeros const char*
---@param popup_max_height_in_items int
---@return bool
function _imgui.ComboEx(label, current_item, items_separated_by_zeros, popup_max_height_in_items) end


--- Implied popup_max_height_in_items = -1
---@param label const char*
---@param current_item int*
---@param items_getter bool (*items_getter)(void* data, int idx, const char** out_text)
---@param data void*
---@param items_count int
---@return bool
function _imgui.ComboCallback(label, current_item, items_getter, data, items_count) end


---@param label const char*
---@param current_item int*
---@param items_getter bool (*items_getter)(void* data, int idx, const char** out_text)
---@param data void*
---@param items_count int
---@param popup_max_height_in_items int
---@return bool
function _imgui.ComboCallbackEx(label, current_item, items_getter, data, items_count, popup_max_height_in_items) end

--- Widgets: Drag Sliders
--- - CTRL+Click on any drag box to turn them into an input box. Manually input values aren't clamped by default and can go off-bounds. Use ImGuiSliderFlags_AlwaysClamp to always clamp.
--- - For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, note that a 'float v[X]' function argument is the same as 'float* v',
---   the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x
--- - Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
--- - Format string may also be set to NULL or use the default format ("%f" or "%d").
--- - Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by 5 pixels to increase value by 1). For gamepad/keyboard navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision).
--- - Use v_min < v_max to clamp edits to given limits. Note that CTRL+Click manual input can override those limits if ImGuiSliderFlags_AlwaysClamp is not used.
--- - Use v_max = FLT_MAX / INT_MAX etc to avoid clamping to a maximum, same with v_min = -FLT_MAX / INT_MIN to avoid clamping to a minimum.
--- - We use the same sets of flags for DragXXX() and SliderXXX() functions as the features are the same and it makes it easier to swap them.
--- - Legacy: Pre-1.78 there are DragXXX() function signatures that takes a final `float power=1.0f' argument instead of the `ImGuiSliderFlags flags=0' argument.
---   If you get a warning converting a float to ImGuiSliderFlags, read https:---github.com/ocornut/imgui/issues/3361
--- Implied v_speed = 1.0f, v_min = 0.0f, v_max = 0.0f, format = "%.3f", flags = 0
---@param label const char*
---@param v float*
---@return bool
function _imgui.DragFloat(label, v) end


--- If v_min >= v_max we have no bound
---@param label const char*
---@param v float*
---@param v_speed float
---@param v_min float
---@param v_max float
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.DragFloatEx(label, v, v_speed, v_min, v_max, format, flags) end


--- Implied v_speed = 1.0f, v_min = 0.0f, v_max = 0.0f, format = "%.3f", flags = 0
---@param label const char*
---@param v float
---@return bool
function _imgui.DragFloat2(label, v) end


---@param label const char*
---@param v float
---@param v_speed float
---@param v_min float
---@param v_max float
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.DragFloat2Ex(label, v, v_speed, v_min, v_max, format, flags) end


--- Implied v_speed = 1.0f, v_min = 0.0f, v_max = 0.0f, format = "%.3f", flags = 0
---@param label const char*
---@param v float
---@return bool
function _imgui.DragFloat3(label, v) end


---@param label const char*
---@param v float
---@param v_speed float
---@param v_min float
---@param v_max float
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.DragFloat3Ex(label, v, v_speed, v_min, v_max, format, flags) end


--- Implied v_speed = 1.0f, v_min = 0.0f, v_max = 0.0f, format = "%.3f", flags = 0
---@param label const char*
---@param v float
---@return bool
function _imgui.DragFloat4(label, v) end


---@param label const char*
---@param v float
---@param v_speed float
---@param v_min float
---@param v_max float
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.DragFloat4Ex(label, v, v_speed, v_min, v_max, format, flags) end


--- Implied v_speed = 1.0f, v_min = 0.0f, v_max = 0.0f, format = "%.3f", format_max = NULL, flags = 0
---@param label const char*
---@param v_current_min float*
---@param v_current_max float*
---@return bool
function _imgui.DragFloatRange2(label, v_current_min, v_current_max) end


---@param label const char*
---@param v_current_min float*
---@param v_current_max float*
---@param v_speed float
---@param v_min float
---@param v_max float
---@param format const char*
---@param format_max const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.DragFloatRange2Ex(label, v_current_min, v_current_max, v_speed, v_min, v_max, format, format_max, flags) end


--- Implied v_speed = 1.0f, v_min = 0, v_max = 0, format = "%d", flags = 0
---@param label const char*
---@param v int*
---@return bool
function _imgui.DragInt(label, v) end


--- If v_min >= v_max we have no bound
---@param label const char*
---@param v int*
---@param v_speed float
---@param v_min int
---@param v_max int
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.DragIntEx(label, v, v_speed, v_min, v_max, format, flags) end


--- Implied v_speed = 1.0f, v_min = 0, v_max = 0, format = "%d", flags = 0
---@param label const char*
---@param v int
---@return bool
function _imgui.DragInt2(label, v) end


---@param label const char*
---@param v int
---@param v_speed float
---@param v_min int
---@param v_max int
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.DragInt2Ex(label, v, v_speed, v_min, v_max, format, flags) end


--- Implied v_speed = 1.0f, v_min = 0, v_max = 0, format = "%d", flags = 0
---@param label const char*
---@param v int
---@return bool
function _imgui.DragInt3(label, v) end


---@param label const char*
---@param v int
---@param v_speed float
---@param v_min int
---@param v_max int
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.DragInt3Ex(label, v, v_speed, v_min, v_max, format, flags) end


--- Implied v_speed = 1.0f, v_min = 0, v_max = 0, format = "%d", flags = 0
---@param label const char*
---@param v int
---@return bool
function _imgui.DragInt4(label, v) end


---@param label const char*
---@param v int
---@param v_speed float
---@param v_min int
---@param v_max int
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.DragInt4Ex(label, v, v_speed, v_min, v_max, format, flags) end


--- Implied v_speed = 1.0f, v_min = 0, v_max = 0, format = "%d", format_max = NULL, flags = 0
---@param label const char*
---@param v_current_min int*
---@param v_current_max int*
---@return bool
function _imgui.DragIntRange2(label, v_current_min, v_current_max) end


---@param label const char*
---@param v_current_min int*
---@param v_current_max int*
---@param v_speed float
---@param v_min int
---@param v_max int
---@param format const char*
---@param format_max const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.DragIntRange2Ex(label, v_current_min, v_current_max, v_speed, v_min, v_max, format, format_max, flags) end


--- Implied v_speed = 1.0f, p_min = NULL, p_max = NULL, format = NULL, flags = 0
---@param label const char*
---@param data_type ImGuiDataType
---@param p_data void*
---@return bool
function _imgui.DragScalar(label, data_type, p_data) end


---@param label const char*
---@param data_type ImGuiDataType
---@param p_data void*
---@param v_speed float
---@param p_min const void*
---@param p_max const void*
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.DragScalarEx(label, data_type, p_data, v_speed, p_min, p_max, format, flags) end


--- Implied v_speed = 1.0f, p_min = NULL, p_max = NULL, format = NULL, flags = 0
---@param label const char*
---@param data_type ImGuiDataType
---@param p_data void*
---@param components int
---@return bool
function _imgui.DragScalarN(label, data_type, p_data, components) end


---@param label const char*
---@param data_type ImGuiDataType
---@param p_data void*
---@param components int
---@param v_speed float
---@param p_min const void*
---@param p_max const void*
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.DragScalarNEx(label, data_type, p_data, components, v_speed, p_min, p_max, format, flags) end

--- Widgets: Regular Sliders
--- - CTRL+Click on any slider to turn them into an input box. Manually input values aren't clamped by default and can go off-bounds. Use ImGuiSliderFlags_AlwaysClamp to always clamp.
--- - Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. "%.3f" -> 1.234; "%5.2f secs" -> 01.23 secs; "Biscuit: %.0f" -> Biscuit: 1; etc.
--- - Format string may also be set to NULL or use the default format ("%f" or "%d").
--- - Legacy: Pre-1.78 there are SliderXXX() function signatures that takes a final `float power=1.0f' argument instead of the `ImGuiSliderFlags flags=0' argument.
---   If you get a warning converting a float to ImGuiSliderFlags, read https:---github.com/ocornut/imgui/issues/3361
--- Implied format = "%.3f", flags = 0
---@param label const char*
---@param v float*
---@param v_min float
---@param v_max float
---@return bool
function _imgui.SliderFloat(label, v, v_min, v_max) end


--- adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display.
---@param label const char*
---@param v float*
---@param v_min float
---@param v_max float
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.SliderFloatEx(label, v, v_min, v_max, format, flags) end


--- Implied format = "%.3f", flags = 0
---@param label const char*
---@param v float
---@param v_min float
---@param v_max float
---@return bool
function _imgui.SliderFloat2(label, v, v_min, v_max) end


---@param label const char*
---@param v float
---@param v_min float
---@param v_max float
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.SliderFloat2Ex(label, v, v_min, v_max, format, flags) end


--- Implied format = "%.3f", flags = 0
---@param label const char*
---@param v float
---@param v_min float
---@param v_max float
---@return bool
function _imgui.SliderFloat3(label, v, v_min, v_max) end


---@param label const char*
---@param v float
---@param v_min float
---@param v_max float
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.SliderFloat3Ex(label, v, v_min, v_max, format, flags) end


--- Implied format = "%.3f", flags = 0
---@param label const char*
---@param v float
---@param v_min float
---@param v_max float
---@return bool
function _imgui.SliderFloat4(label, v, v_min, v_max) end


---@param label const char*
---@param v float
---@param v_min float
---@param v_max float
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.SliderFloat4Ex(label, v, v_min, v_max, format, flags) end


--- Implied v_degrees_min = -360.0f, v_degrees_max = +360.0f, format = "%.0f deg", flags = 0
---@param label const char*
---@param v_rad float*
---@return bool
function _imgui.SliderAngle(label, v_rad) end


---@param label const char*
---@param v_rad float*
---@param v_degrees_min float
---@param v_degrees_max float
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.SliderAngleEx(label, v_rad, v_degrees_min, v_degrees_max, format, flags) end


--- Implied format = "%d", flags = 0
---@param label const char*
---@param v int*
---@param v_min int
---@param v_max int
---@return bool
function _imgui.SliderInt(label, v, v_min, v_max) end


---@param label const char*
---@param v int*
---@param v_min int
---@param v_max int
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.SliderIntEx(label, v, v_min, v_max, format, flags) end


--- Implied format = "%d", flags = 0
---@param label const char*
---@param v int
---@param v_min int
---@param v_max int
---@return bool
function _imgui.SliderInt2(label, v, v_min, v_max) end


---@param label const char*
---@param v int
---@param v_min int
---@param v_max int
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.SliderInt2Ex(label, v, v_min, v_max, format, flags) end


--- Implied format = "%d", flags = 0
---@param label const char*
---@param v int
---@param v_min int
---@param v_max int
---@return bool
function _imgui.SliderInt3(label, v, v_min, v_max) end


---@param label const char*
---@param v int
---@param v_min int
---@param v_max int
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.SliderInt3Ex(label, v, v_min, v_max, format, flags) end


--- Implied format = "%d", flags = 0
---@param label const char*
---@param v int
---@param v_min int
---@param v_max int
---@return bool
function _imgui.SliderInt4(label, v, v_min, v_max) end


---@param label const char*
---@param v int
---@param v_min int
---@param v_max int
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.SliderInt4Ex(label, v, v_min, v_max, format, flags) end


--- Implied format = NULL, flags = 0
---@param label const char*
---@param data_type ImGuiDataType
---@param p_data void*
---@param p_min const void*
---@param p_max const void*
---@return bool
function _imgui.SliderScalar(label, data_type, p_data, p_min, p_max) end


---@param label const char*
---@param data_type ImGuiDataType
---@param p_data void*
---@param p_min const void*
---@param p_max const void*
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.SliderScalarEx(label, data_type, p_data, p_min, p_max, format, flags) end


--- Implied format = NULL, flags = 0
---@param label const char*
---@param data_type ImGuiDataType
---@param p_data void*
---@param components int
---@param p_min const void*
---@param p_max const void*
---@return bool
function _imgui.SliderScalarN(label, data_type, p_data, components, p_min, p_max) end


---@param label const char*
---@param data_type ImGuiDataType
---@param p_data void*
---@param components int
---@param p_min const void*
---@param p_max const void*
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.SliderScalarNEx(label, data_type, p_data, components, p_min, p_max, format, flags) end


--- Implied format = "%.3f", flags = 0
---@param label const char*
---@param size ImVec2
---@param v float*
---@param v_min float
---@param v_max float
---@return bool
function _imgui.VSliderFloat(label, size, v, v_min, v_max) end


---@param label const char*
---@param size ImVec2
---@param v float*
---@param v_min float
---@param v_max float
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.VSliderFloatEx(label, size, v, v_min, v_max, format, flags) end


--- Implied format = "%d", flags = 0
---@param label const char*
---@param size ImVec2
---@param v int*
---@param v_min int
---@param v_max int
---@return bool
function _imgui.VSliderInt(label, size, v, v_min, v_max) end


---@param label const char*
---@param size ImVec2
---@param v int*
---@param v_min int
---@param v_max int
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.VSliderIntEx(label, size, v, v_min, v_max, format, flags) end


--- Implied format = NULL, flags = 0
---@param label const char*
---@param size ImVec2
---@param data_type ImGuiDataType
---@param p_data void*
---@param p_min const void*
---@param p_max const void*
---@return bool
function _imgui.VSliderScalar(label, size, data_type, p_data, p_min, p_max) end


---@param label const char*
---@param size ImVec2
---@param data_type ImGuiDataType
---@param p_data void*
---@param p_min const void*
---@param p_max const void*
---@param format const char*
---@param flags ImGuiSliderFlags
---@return bool
function _imgui.VSliderScalarEx(label, size, data_type, p_data, p_min, p_max, format, flags) end

--- Widgets: Input with Keyboard
--- - If you want to use InputText() with std::string or any custom dynamic string type, see misc/cpp/imgui_stdlib.h and comments in imgui_demo.cpp.
--- - Most of the ImGuiInputTextFlags flags are only useful for InputText() and not for InputFloatX, InputIntX, InputDouble etc.
--- Implied callback = NULL, user_data = NULL
---@param label const char*
---@param buf char*
---@param buf_size size_t
---@param flags ImGuiInputTextFlags
---@return bool
function _imgui.InputText(label, buf, buf_size, flags) end


---@param label const char*
---@param buf char*
---@param buf_size size_t
---@param flags ImGuiInputTextFlags
---@param callback ImGuiInputTextCallback
---@param user_data void*
---@return bool
function _imgui.InputTextEx(label, buf, buf_size, flags, callback, user_data) end


--- Implied size = ImVec2(0, 0), flags = 0, callback = NULL, user_data = NULL
---@param label const char*
---@param buf char*
---@param buf_size size_t
---@return bool
function _imgui.InputTextMultiline(label, buf, buf_size) end


---@param label const char*
---@param buf char*
---@param buf_size size_t
---@param size ImVec2
---@param flags ImGuiInputTextFlags
---@param callback ImGuiInputTextCallback
---@param user_data void*
---@return bool
function _imgui.InputTextMultilineEx(label, buf, buf_size, size, flags, callback, user_data) end


--- Implied callback = NULL, user_data = NULL
---@param label const char*
---@param hint const char*
---@param buf char*
---@param buf_size size_t
---@param flags ImGuiInputTextFlags
---@return bool
function _imgui.InputTextWithHint(label, hint, buf, buf_size, flags) end


---@param label const char*
---@param hint const char*
---@param buf char*
---@param buf_size size_t
---@param flags ImGuiInputTextFlags
---@param callback ImGuiInputTextCallback
---@param user_data void*
---@return bool
function _imgui.InputTextWithHintEx(label, hint, buf, buf_size, flags, callback, user_data) end


--- Implied step = 0.0f, step_fast = 0.0f, format = "%.3f", flags = 0
---@param label const char*
---@param v float*
---@return bool
function _imgui.InputFloat(label, v) end


---@param label const char*
---@param v float*
---@param step float
---@param step_fast float
---@param format const char*
---@param flags ImGuiInputTextFlags
---@return bool
function _imgui.InputFloatEx(label, v, step, step_fast, format, flags) end


--- Implied format = "%.3f", flags = 0
---@param label const char*
---@param v float
---@return bool
function _imgui.InputFloat2(label, v) end


---@param label const char*
---@param v float
---@param format const char*
---@param flags ImGuiInputTextFlags
---@return bool
function _imgui.InputFloat2Ex(label, v, format, flags) end


--- Implied format = "%.3f", flags = 0
---@param label const char*
---@param v float
---@return bool
function _imgui.InputFloat3(label, v) end


---@param label const char*
---@param v float
---@param format const char*
---@param flags ImGuiInputTextFlags
---@return bool
function _imgui.InputFloat3Ex(label, v, format, flags) end


--- Implied format = "%.3f", flags = 0
---@param label const char*
---@param v float
---@return bool
function _imgui.InputFloat4(label, v) end


---@param label const char*
---@param v float
---@param format const char*
---@param flags ImGuiInputTextFlags
---@return bool
function _imgui.InputFloat4Ex(label, v, format, flags) end


--- Implied step = 1, step_fast = 100, flags = 0
---@param label const char*
---@param v int*
---@return bool
function _imgui.InputInt(label, v) end


---@param label const char*
---@param v int*
---@param step int
---@param step_fast int
---@param flags ImGuiInputTextFlags
---@return bool
function _imgui.InputIntEx(label, v, step, step_fast, flags) end


---@param label const char*
---@param v int
---@param flags ImGuiInputTextFlags
---@return bool
function _imgui.InputInt2(label, v, flags) end


---@param label const char*
---@param v int
---@param flags ImGuiInputTextFlags
---@return bool
function _imgui.InputInt3(label, v, flags) end


---@param label const char*
---@param v int
---@param flags ImGuiInputTextFlags
---@return bool
function _imgui.InputInt4(label, v, flags) end


--- Implied step = 0.0, step_fast = 0.0, format = "%.6f", flags = 0
---@param label const char*
---@param v double*
---@return bool
function _imgui.InputDouble(label, v) end


---@param label const char*
---@param v double*
---@param step double
---@param step_fast double
---@param format const char*
---@param flags ImGuiInputTextFlags
---@return bool
function _imgui.InputDoubleEx(label, v, step, step_fast, format, flags) end


--- Implied p_step = NULL, p_step_fast = NULL, format = NULL, flags = 0
---@param label const char*
---@param data_type ImGuiDataType
---@param p_data void*
---@return bool
function _imgui.InputScalar(label, data_type, p_data) end


---@param label const char*
---@param data_type ImGuiDataType
---@param p_data void*
---@param p_step const void*
---@param p_step_fast const void*
---@param format const char*
---@param flags ImGuiInputTextFlags
---@return bool
function _imgui.InputScalarEx(label, data_type, p_data, p_step, p_step_fast, format, flags) end


--- Implied p_step = NULL, p_step_fast = NULL, format = NULL, flags = 0
---@param label const char*
---@param data_type ImGuiDataType
---@param p_data void*
---@param components int
---@return bool
function _imgui.InputScalarN(label, data_type, p_data, components) end


---@param label const char*
---@param data_type ImGuiDataType
---@param p_data void*
---@param components int
---@param p_step const void*
---@param p_step_fast const void*
---@param format const char*
---@param flags ImGuiInputTextFlags
---@return bool
function _imgui.InputScalarNEx(label, data_type, p_data, components, p_step, p_step_fast, format, flags) end

--- Widgets: Color Editor/Picker (tip: the ColorEdit* functions have a little color square that can be left-clicked to open a picker, and right-clicked to open an option menu.)
--- - Note that in C++ a 'float v[X]' function argument is the _same_ as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible.
--- - You can pass the address of a first float element out of a contiguous structure, e.g. &myvector.x
---@param label const char*
---@param col float
---@param flags ImGuiColorEditFlags
---@return bool
function _imgui.ColorEdit3(label, col, flags) end


---@param label const char*
---@param col float
---@param flags ImGuiColorEditFlags
---@return bool
function _imgui.ColorEdit4(label, col, flags) end


---@param label const char*
---@param col float
---@param flags ImGuiColorEditFlags
---@return bool
function _imgui.ColorPicker3(label, col, flags) end


---@param label const char*
---@param col float
---@param flags ImGuiColorEditFlags
---@param ref_col const float*
---@return bool
function _imgui.ColorPicker4(label, col, flags, ref_col) end


--- Implied size = ImVec2(0, 0)
---@param desc_id const char*
---@param col ImVec4
---@param flags ImGuiColorEditFlags
---@return bool
function _imgui.ColorButton(desc_id, col, flags) end


--- display a color square/button, hover for details, return true when pressed.
---@param desc_id const char*
---@param col ImVec4
---@param flags ImGuiColorEditFlags
---@param size ImVec2
---@return bool
function _imgui.ColorButtonEx(desc_id, col, flags, size) end


--- initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.
---@param flags ImGuiColorEditFlags
---@return void
function _imgui.SetColorEditOptions(flags) end

--- Widgets: Trees
--- - TreeNode functions return true when the node is open, in which case you need to also call TreePop() when you are finished displaying the tree node contents.
---@param label const char*
---@return bool
function _imgui.TreeNode(label) end


--- helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().
---@param str_id const char*
---@param fmt const char*
---@return bool
function _imgui.TreeNodeStr(str_id, fmt, ...) end


--- "
---@param ptr_id const void*
---@param fmt const char*
---@return bool
function _imgui.TreeNodePtr(ptr_id, fmt, ...) end


---@param str_id const char*
---@param fmt const char*
---@param args va_list
---@return bool
function _imgui.TreeNodeV(str_id, fmt, args) end


---@param ptr_id const void*
---@param fmt const char*
---@param args va_list
---@return bool
function _imgui.TreeNodeVPtr(ptr_id, fmt, args) end


---@param label const char*
---@param flags ImGuiTreeNodeFlags
---@return bool
function _imgui.TreeNodeEx(label, flags) end


---@param str_id const char*
---@param flags ImGuiTreeNodeFlags
---@param fmt const char*
---@return bool
function _imgui.TreeNodeExStr(str_id, flags, fmt, ...) end


---@param ptr_id const void*
---@param flags ImGuiTreeNodeFlags
---@param fmt const char*
---@return bool
function _imgui.TreeNodeExPtr(ptr_id, flags, fmt, ...) end


---@param str_id const char*
---@param flags ImGuiTreeNodeFlags
---@param fmt const char*
---@param args va_list
---@return bool
function _imgui.TreeNodeExV(str_id, flags, fmt, args) end


---@param ptr_id const void*
---@param flags ImGuiTreeNodeFlags
---@param fmt const char*
---@param args va_list
---@return bool
function _imgui.TreeNodeExVPtr(ptr_id, flags, fmt, args) end


--- ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call TreePush/TreePop yourself if desired.
---@param str_id const char*
---@return void
function _imgui.TreePush(str_id) end


--- "
---@param ptr_id const void*
---@return void
function _imgui.TreePushPtr(ptr_id) end


--- ~ Unindent()+PopId()
---@return void
function _imgui.TreePop() end


--- horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode
---@return float
function _imgui.GetTreeNodeToLabelSpacing() end


--- if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().
---@param label const char*
---@param flags ImGuiTreeNodeFlags
---@return bool
function _imgui.CollapsingHeader(label, flags) end


--- when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.
---@param label const char*
---@param p_visible bool*
---@param flags ImGuiTreeNodeFlags
---@return bool
function _imgui.CollapsingHeaderBoolPtr(label, p_visible, flags) end


--- set next TreeNode/CollapsingHeader open state.
---@param is_open bool
---@param cond ImGuiCond
---@return void
function _imgui.SetNextItemOpen(is_open, cond) end

--- Widgets: Selectables
--- - A selectable highlights when hovered, and can display another color when selected.
--- - Neighbors selectable extend their highlight bounds in order to leave no gap between them. This is so a series of selected Selectable appear contiguous.
--- Implied selected = false, flags = 0, size = ImVec2(0, 0)
---@param label const char*
---@return bool
function _imgui.Selectable(label) end


--- "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height
---@param label const char*
---@param selected bool
---@param flags ImGuiSelectableFlags
---@param size ImVec2
---@return bool
function _imgui.SelectableEx(label, selected, flags, size) end


--- Implied size = ImVec2(0, 0)
---@param label const char*
---@param p_selected bool*
---@param flags ImGuiSelectableFlags
---@return bool
function _imgui.SelectableBoolPtr(label, p_selected, flags) end


--- "bool* p_selected" point to the selection state (read-write), as a convenient helper.
---@param label const char*
---@param p_selected bool*
---@param flags ImGuiSelectableFlags
---@param size ImVec2
---@return bool
function _imgui.SelectableBoolPtrEx(label, p_selected, flags, size) end

--- Widgets: List Boxes
--- - This is essentially a thin wrapper to using BeginChild/EndChild with some stylistic changes.
--- - The BeginListBox()/EndListBox() api allows you to manage your contents and selection state however you want it, by creating e.g. Selectable() or any items.
--- - The simplified/old ListBox() api are helpers over BeginListBox()/EndListBox() which are kept available for convenience purpose. This is analoguous to how Combos are created.
--- - Choose frame width:   size.x > 0.0f: custom  /  size.x < 0.0f or -FLT_MIN: right-align   /  size.x = 0.0f (default): use current ItemWidth
--- - Choose frame height:  size.y > 0.0f: custom  /  size.y < 0.0f or -FLT_MIN: bottom-align  /  size.y = 0.0f (default): arbitrary default height which can fit ~7 items
--- open a framed scrolling region
---@param label const char*
---@param size ImVec2
---@return bool
function _imgui.BeginListBox(label, size) end


--- only call EndListBox() if BeginListBox() returned true!
---@return void
function _imgui.EndListBox() end


---@param label const char*
---@param current_item int*
---@param items const char*const
---@param items_count int
---@param height_in_items int
---@return bool
function _imgui.ListBox(label, current_item, items, items_count, height_in_items) end


--- Implied height_in_items = -1
---@param label const char*
---@param current_item int*
---@param items_getter bool (*items_getter)(void* data, int idx, const char** out_text)
---@param data void*
---@param items_count int
---@return bool
function _imgui.ListBoxCallback(label, current_item, items_getter, data, items_count) end


---@param label const char*
---@param current_item int*
---@param items_getter bool (*items_getter)(void* data, int idx, const char** out_text)
---@param data void*
---@param items_count int
---@param height_in_items int
---@return bool
function _imgui.ListBoxCallbackEx(label, current_item, items_getter, data, items_count, height_in_items) end

--- Widgets: Data Plotting
--- - Consider using ImPlot (https:---github.com/epezent/implot) which is much better!
--- Implied values_offset = 0, overlay_text = NULL, scale_min = FLT_MAX, scale_max = FLT_MAX, graph_size = ImVec2(0, 0), stride = sizeof(float)
---@param label const char*
---@param values const float*
---@param values_count int
---@return void
function _imgui.PlotLines(label, values, values_count) end


---@param label const char*
---@param values const float*
---@param values_count int
---@param values_offset int
---@param overlay_text const char*
---@param scale_min float
---@param scale_max float
---@param graph_size ImVec2
---@param stride int
---@return void
function _imgui.PlotLinesEx(label, values, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size, stride) end


--- Implied values_offset = 0, overlay_text = NULL, scale_min = FLT_MAX, scale_max = FLT_MAX, graph_size = ImVec2(0, 0)
---@param label const char*
---@param values_getter float (*values_getter)(void* data, int idx)
---@param data void*
---@param values_count int
---@return void
function _imgui.PlotLinesCallback(label, values_getter, data, values_count) end


---@param label const char*
---@param values_getter float (*values_getter)(void* data, int idx)
---@param data void*
---@param values_count int
---@param values_offset int
---@param overlay_text const char*
---@param scale_min float
---@param scale_max float
---@param graph_size ImVec2
---@return void
function _imgui.PlotLinesCallbackEx(label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size) end


--- Implied values_offset = 0, overlay_text = NULL, scale_min = FLT_MAX, scale_max = FLT_MAX, graph_size = ImVec2(0, 0), stride = sizeof(float)
---@param label const char*
---@param values const float*
---@param values_count int
---@return void
function _imgui.PlotHistogram(label, values, values_count) end


---@param label const char*
---@param values const float*
---@param values_count int
---@param values_offset int
---@param overlay_text const char*
---@param scale_min float
---@param scale_max float
---@param graph_size ImVec2
---@param stride int
---@return void
function _imgui.PlotHistogramEx(label, values, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size, stride) end


--- Implied values_offset = 0, overlay_text = NULL, scale_min = FLT_MAX, scale_max = FLT_MAX, graph_size = ImVec2(0, 0)
---@param label const char*
---@param values_getter float (*values_getter)(void* data, int idx)
---@param data void*
---@param values_count int
---@return void
function _imgui.PlotHistogramCallback(label, values_getter, data, values_count) end


---@param label const char*
---@param values_getter float (*values_getter)(void* data, int idx)
---@param data void*
---@param values_count int
---@param values_offset int
---@param overlay_text const char*
---@param scale_min float
---@param scale_max float
---@param graph_size ImVec2
---@return void
function _imgui.PlotHistogramCallbackEx(label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size) end

--- Widgets: Menus
--- - Use BeginMenuBar() on a window ImGuiWindowFlags_MenuBar to append to its menu bar.
--- - Use BeginMainMenuBar() to create a menu bar at the top of the screen and append to it.
--- - Use BeginMenu() to create a menu. You can call BeginMenu() multiple time with the same identifier to append more items to it.
--- - Not that MenuItem() keyboardshortcuts are displayed as a convenience but _not processed_ by Dear ImGui at the moment.
--- append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window).
---@return bool
function _imgui.BeginMenuBar() end


--- only call EndMenuBar() if BeginMenuBar() returns true!
---@return void
function _imgui.EndMenuBar() end


--- create and append to a full screen menu-bar.
---@return bool
function _imgui.BeginMainMenuBar() end


--- only call EndMainMenuBar() if BeginMainMenuBar() returns true!
---@return void
function _imgui.EndMainMenuBar() end


--- Implied enabled = true
---@param label const char*
---@return bool
function _imgui.BeginMenu(label) end


--- create a sub-menu entry. only call EndMenu() if this returns true!
---@param label const char*
---@param enabled bool
---@return bool
function _imgui.BeginMenuEx(label, enabled) end


--- only call EndMenu() if BeginMenu() returns true!
---@return void
function _imgui.EndMenu() end


--- Implied shortcut = NULL, selected = false, enabled = true
---@param label const char*
---@return bool
function _imgui.MenuItem(label) end


--- return true when activated.
---@param label const char*
---@param shortcut const char*
---@param selected bool
---@param enabled bool
---@return bool
function _imgui.MenuItemEx(label, shortcut, selected, enabled) end


--- return true when activated + toggle (*p_selected) if p_selected != NULL
---@param label const char*
---@param shortcut const char*
---@param p_selected bool*
---@param enabled bool
---@return bool
function _imgui.MenuItemBoolPtr(label, shortcut, p_selected, enabled) end

--- Tooltips
--- - Tooltip are windows following the mouse. They do not take focus away.
--- begin/append a tooltip window. to create full-featured tooltip (with any kind of items).
---@return void
function _imgui.BeginTooltip() end


---@return void
function _imgui.EndTooltip() end


--- set a text-only tooltip, typically use with ImGui::IsItemHovered(). override any previous call to SetTooltip().
---@param fmt const char*
---@return void
function _imgui.SetTooltip(fmt, ...) end


---@param fmt const char*
---@param args va_list
---@return void
function _imgui.SetTooltipV(fmt, args) end

--- Popups: begin/end functions
---  - BeginPopup(): query popup state, if open start appending into the window. Call EndPopup() afterwards. ImGuiWindowFlags are forwarded to the window.
---  - BeginPopupModal(): block every interactions behind the window, cannot be closed by user, add a dimming background, has a title bar.
--- return true if the popup is open, and you can start outputting to it.
---@param str_id const char*
---@param flags ImGuiWindowFlags
---@return bool
function _imgui.BeginPopup(str_id, flags) end


--- return true if the modal is open, and you can start outputting to it.
---@param name const char*
---@param p_open bool*
---@param flags ImGuiWindowFlags
---@return bool
function _imgui.BeginPopupModal(name, p_open, flags) end


--- only call EndPopup() if BeginPopupXXX() returns true!
---@return void
function _imgui.EndPopup() end

--- Popups: open/close functions
---  - OpenPopup(): set popup state to open. ImGuiPopupFlags are available for opening options.
---  - If not modal: they can be closed by clicking anywhere outside them, or by pressing ESCAPE.
---  - CloseCurrentPopup(): use inside the BeginPopup()/EndPopup() scope to close manually.
---  - CloseCurrentPopup() is called by default by Selectable()/MenuItem() when activated (FIXME: need some options).
---  - Use ImGuiPopupFlags_NoOpenOverExistingPopup to avoid opening a popup if there's already one at the same level. This is equivalent to e.g. testing for !IsAnyPopupOpen() prior to OpenPopup().
---  - Use IsWindowAppearing() after BeginPopup() to tell if a window just opened.
---  - IMPORTANT: Notice that for OpenPopupOnItemClick() we exceptionally default flags to 1 (== ImGuiPopupFlags_MouseButtonRight) for backward compatibility with older API taking 'int mouse_button = 1' parameter
--- call to mark popup as open (don't call every frame!).
---@param str_id const char*
---@param popup_flags ImGuiPopupFlags
---@return void
function _imgui.OpenPopup(str_id, popup_flags) end


--- id overload to facilitate calling from nested stacks
---@param id ImGuiID
---@param popup_flags ImGuiPopupFlags
---@return void
function _imgui.OpenPopupID(id, popup_flags) end


--- helper to open popup when clicked on last item. Default to ImGuiPopupFlags_MouseButtonRight == 1. (note: actually triggers on the mouse _released_ event to be consistent with popup behaviors)
---@param str_id const char*
---@param popup_flags ImGuiPopupFlags
---@return void
function _imgui.OpenPopupOnItemClick(str_id, popup_flags) end


--- manually close the popup we have begin-ed into.
---@return void
function _imgui.CloseCurrentPopup() end

--- Popups: open+begin combined functions helpers
---  - Helpers to do OpenPopup+BeginPopup where the Open action is triggered by e.g. hovering an item and right-clicking.
---  - They are convenient to easily create context menus, hence the name.
---  - IMPORTANT: Notice that BeginPopupContextXXX takes ImGuiPopupFlags just like OpenPopup() and unlike BeginPopup(). For full consistency, we may add ImGuiWindowFlags to the BeginPopupContextXXX functions in the future.
---  - IMPORTANT: Notice that we exceptionally default their flags to 1 (== ImGuiPopupFlags_MouseButtonRight) for backward compatibility with older API taking 'int mouse_button = 1' parameter, so if you add other flags remember to re-add the ImGuiPopupFlags_MouseButtonRight.
--- Implied str_id = NULL, popup_flags = 1
---@return bool
function _imgui.BeginPopupContextItem() end


--- open+begin popup when clicked on last item. Use str_id==NULL to associate the popup to previous item. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!
---@param str_id const char*
---@param popup_flags ImGuiPopupFlags
---@return bool
function _imgui.BeginPopupContextItemEx(str_id, popup_flags) end


--- Implied str_id = NULL, popup_flags = 1
---@return bool
function _imgui.BeginPopupContextWindow() end


--- open+begin popup when clicked on current window.
---@param str_id const char*
---@param popup_flags ImGuiPopupFlags
---@return bool
function _imgui.BeginPopupContextWindowEx(str_id, popup_flags) end


--- Implied str_id = NULL, popup_flags = 1
---@return bool
function _imgui.BeginPopupContextVoid() end


--- open+begin popup when clicked in void (where there are no windows).
---@param str_id const char*
---@param popup_flags ImGuiPopupFlags
---@return bool
function _imgui.BeginPopupContextVoidEx(str_id, popup_flags) end

--- Popups: query functions
---  - IsPopupOpen(): return true if the popup is open at the current BeginPopup() level of the popup stack.
---  - IsPopupOpen() with ImGuiPopupFlags_AnyPopupId: return true if any popup is open at the current BeginPopup() level of the popup stack.
---  - IsPopupOpen() with ImGuiPopupFlags_AnyPopupId + ImGuiPopupFlags_AnyPopupLevel: return true if any popup is open.
--- return true if the popup is open.
---@param str_id const char*
---@param flags ImGuiPopupFlags
---@return bool
function _imgui.IsPopupOpen(str_id, flags) end

--- Tables
--- - Full-featured replacement for old Columns API.
--- - See Demo->Tables for demo code. See top of imgui_tables.cpp for general commentary.
--- - See ImGuiTableFlags_ and ImGuiTableColumnFlags_ enums for a description of available flags.
--- The typical call flow is:
--- - 1. Call BeginTable(), early out if returning false.
--- - 2. Optionally call TableSetupColumn() to submit column name/flags/defaults.
--- - 3. Optionally call TableSetupScrollFreeze() to request scroll freezing of columns/rows.
--- - 4. Optionally call TableHeadersRow() to submit a header row. Names are pulled from TableSetupColumn() data.
--- - 5. Populate contents:
---    - In most situations you can use TableNextRow() + TableSetColumnIndex(N) to start appending into a column.
---    - If you are using tables as a sort of grid, where every columns is holding the same type of contents,
---      you may prefer using TableNextColumn() instead of TableNextRow() + TableSetColumnIndex().
---      TableNextColumn() will automatically wrap-around into the next row if needed.
---    - IMPORTANT: Comparatively to the old Columns() API, we need to call TableNextColumn() for the first column!
---    - Summary of possible call flow:
---        --------------------------------------------------------------------------------------------------------
---        TableNextRow() -> TableSetColumnIndex(0) -> Text("Hello 0") -> TableSetColumnIndex(1) -> Text("Hello 1")  --- OK
---        TableNextRow() -> TableNextColumn()      -> Text("Hello 0") -> TableNextColumn()      -> Text("Hello 1")  --- OK
---                          TableNextColumn()      -> Text("Hello 0") -> TableNextColumn()      -> Text("Hello 1")  --- OK: TableNextColumn() automatically gets to next row!
---        TableNextRow()                           -> Text("Hello 0")                                               --- Not OK! Missing TableSetColumnIndex() or TableNextColumn()! Text will not appear!
---        --------------------------------------------------------------------------------------------------------
--- - 5. Call EndTable()
--- Implied outer_size = ImVec2(0.0f, 0.0f), inner_width = 0.0f
---@param str_id const char*
---@param column int
---@param flags ImGuiTableFlags
---@return bool
function _imgui.BeginTable(str_id, column, flags) end


---@param str_id const char*
---@param column int
---@param flags ImGuiTableFlags
---@param outer_size ImVec2
---@param inner_width float
---@return bool
function _imgui.BeginTableEx(str_id, column, flags, outer_size, inner_width) end


--- only call EndTable() if BeginTable() returns true!
---@return void
function _imgui.EndTable() end


--- Implied row_flags = 0, min_row_height = 0.0f
---@return void
function _imgui.TableNextRow() end


--- append into the first cell of a new row.
---@param row_flags ImGuiTableRowFlags
---@param min_row_height float
---@return void
function _imgui.TableNextRowEx(row_flags, min_row_height) end


--- append into the next column (or first column of next row if currently in last column). Return true when column is visible.
---@return bool
function _imgui.TableNextColumn() end


--- append into the specified column. Return true when column is visible.
---@param column_n int
---@return bool
function _imgui.TableSetColumnIndex(column_n) end

--- Tables: Headers & Columns declaration
--- - Use TableSetupColumn() to specify label, resizing policy, default width/weight, id, various other flags etc.
--- - Use TableHeadersRow() to create a header row and automatically submit a TableHeader() for each column.
---   Headers are required to perform: reordering, sorting, and opening the context menu.
---   The context menu can also be made available in columns body using ImGuiTableFlags_ContextMenuInBody.
--- - You may manually submit headers using TableNextRow() + TableHeader() calls, but this is only useful in
---   some advanced use cases (e.g. adding custom widgets in header row).
--- - Use TableSetupScrollFreeze() to lock columns/rows so they stay visible when scrolled.
--- Implied init_width_or_weight = 0.0f, user_id = 0
---@param label const char*
---@param flags ImGuiTableColumnFlags
---@return void
function _imgui.TableSetupColumn(label, flags) end


---@param label const char*
---@param flags ImGuiTableColumnFlags
---@param init_width_or_weight float
---@param user_id ImGuiID
---@return void
function _imgui.TableSetupColumnEx(label, flags, init_width_or_weight, user_id) end


--- lock columns/rows so they stay visible when scrolled.
---@param cols int
---@param rows int
---@return void
function _imgui.TableSetupScrollFreeze(cols, rows) end


--- submit all headers cells based on data provided to TableSetupColumn() + submit context menu
---@return void
function _imgui.TableHeadersRow() end


--- submit one header cell manually (rarely used)
---@param label const char*
---@return void
function _imgui.TableHeader(label) end

--- Tables: Sorting & Miscellaneous functions
--- - Sorting: call TableGetSortSpecs() to retrieve latest sort specs for the table. NULL when not sorting.
---   When 'sort_specs->SpecsDirty == true' you should sort your data. It will be true when sorting specs have
---   changed since last call, or the first time. Make sure to set 'SpecsDirty = false' after sorting,
---   else you may wastefully sort your data every frame!
--- - Functions args 'int column_n' treat the default value of -1 as the same as passing the current column index.
--- get latest sort specs for the table (NULL if not sorting).  Lifetime: don't hold on this pointer over multiple frames or past any subsequent call to BeginTable().
---@return ImGuiTableSortSpecs*
function _imgui.TableGetSortSpecs() end


--- return number of columns (value passed to BeginTable)
---@return int
function _imgui.TableGetColumnCount() end


--- return current column index.
---@return int
function _imgui.TableGetColumnIndex() end


--- return current row index.
---@return int
function _imgui.TableGetRowIndex() end


--- return "" if column didn't have a name declared by TableSetupColumn(). Pass -1 to use current column.
---@param column_n int
---@return const char*
function _imgui.TableGetColumnName(column_n) end


--- return column flags so you can query their Enabled/Visible/Sorted/Hovered status flags. Pass -1 to use current column.
---@param column_n int
---@return ImGuiTableColumnFlags
function _imgui.TableGetColumnFlags(column_n) end


--- change user accessible enabled/disabled state of a column. Set to false to hide the column. User can use the context menu to change this themselves (right-click in headers, or right-click in columns body with ImGuiTableFlags_ContextMenuInBody)
---@param column_n int
---@param v bool
---@return void
function _imgui.TableSetColumnEnabled(column_n, v) end


--- change the color of a cell, row, or column. See ImGuiTableBgTarget_ flags for details.
---@param target ImGuiTableBgTarget
---@param color ImU32
---@param column_n int
---@return void
function _imgui.TableSetBgColor(target, color, column_n) end

--- Legacy Columns API (prefer using Tables!)
--- - You can also use SameLine(pos_x) to mimic simplified columns.
--- Implied count = 1, id = NULL, border = true
---@return void
function _imgui.Columns() end


---@param count int
---@param id const char*
---@param border bool
---@return void
function _imgui.ColumnsEx(count, id, border) end


--- next column, defaults to current row or next row if the current row is finished
---@return void
function _imgui.NextColumn() end


--- get current column index
---@return int
function _imgui.GetColumnIndex() end


--- get column width (in pixels). pass -1 to use current column
---@param column_index int
---@return float
function _imgui.GetColumnWidth(column_index) end


--- set column width (in pixels). pass -1 to use current column
---@param column_index int
---@param width float
---@return void
function _imgui.SetColumnWidth(column_index, width) end


--- get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f
---@param column_index int
---@return float
function _imgui.GetColumnOffset(column_index) end


--- set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column
---@param column_index int
---@param offset_x float
---@return void
function _imgui.SetColumnOffset(column_index, offset_x) end


---@return int
function _imgui.GetColumnsCount() end

--- Tab Bars, Tabs
--- Note: Tabs are automatically created by the docking system. Use this to create tab bars/tabs yourself without docking being involved.
--- create and append into a TabBar
---@param str_id const char*
---@param flags ImGuiTabBarFlags
---@return bool
function _imgui.BeginTabBar(str_id, flags) end


--- only call EndTabBar() if BeginTabBar() returns true!
---@return void
function _imgui.EndTabBar() end


--- create a Tab. Returns true if the Tab is selected.
---@param label const char*
---@param p_open bool*
---@param flags ImGuiTabItemFlags
---@return bool
function _imgui.BeginTabItem(label, p_open, flags) end


--- only call EndTabItem() if BeginTabItem() returns true!
---@return void
function _imgui.EndTabItem() end


--- create a Tab behaving like a button. return true when clicked. cannot be selected in the tab bar.
---@param label const char*
---@param flags ImGuiTabItemFlags
---@return bool
function _imgui.TabItemButton(label, flags) end


--- notify TabBar or Docking system of a closed tab/window ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name.
---@param tab_or_docked_window_label const char*
---@return void
function _imgui.SetTabItemClosed(tab_or_docked_window_label) end

--- Docking
--- [BETA API] Enable with io.ConfigFlags |= ImGuiConfigFlags_DockingEnable.
--- Note: You can use most Docking facilities without calling any API. You DO NOT need to call DockSpace() to use Docking!
--- - Drag from window title bar or their tab to dock/undock. Hold SHIFT to disable docking/undocking.
--- - Drag from window menu button (upper-left button) to undock an entire node (all windows).
--- - When io.ConfigDockingWithShift == true, you instead need to hold SHIFT to _enable_ docking/undocking.
--- About dockspaces:
--- - Use DockSpace() to create an explicit dock node _within_ an existing window. See Docking demo for details.
--- - Use DockSpaceOverViewport() to create an explicit dock node covering the screen or a specific viewport.
---   This is often used with ImGuiDockNodeFlags_PassthruCentralNode.
--- - Important: Dockspaces need to be submitted _before_ any window they can host. Submit it early in your frame!
--- - Important: Dockspaces need to be kept alive if hidden, otherwise windows docked into it will be undocked.
---   e.g. if you have multiple tabs with a dockspace inside each tab: submit the non-visible dockspaces with ImGuiDockNodeFlags_KeepAliveOnly.
--- Implied size = ImVec2(0, 0), flags = 0, window_class = NULL
---@param id ImGuiID
---@return ImGuiID
function _imgui.DockSpace(id) end


---@param id ImGuiID
---@param size ImVec2
---@param flags ImGuiDockNodeFlags
---@param window_class const ImGuiWindowClass*
---@return ImGuiID
function _imgui.DockSpaceEx(id, size, flags, window_class) end


--- Implied viewport = NULL, flags = 0, window_class = NULL
---@return ImGuiID
function _imgui.DockSpaceOverViewport() end


---@param viewport const ImGuiViewport*
---@param flags ImGuiDockNodeFlags
---@param window_class const ImGuiWindowClass*
---@return ImGuiID
function _imgui.DockSpaceOverViewportEx(viewport, flags, window_class) end


--- set next window dock id
---@param dock_id ImGuiID
---@param cond ImGuiCond
---@return void
function _imgui.SetNextWindowDockID(dock_id, cond) end


--- set next window class (control docking compatibility + provide hints to platform backend via custom viewport flags and platform parent/child relationship)
---@param window_class const ImGuiWindowClass*
---@return void
function _imgui.SetNextWindowClass(window_class) end


---@return ImGuiID
function _imgui.GetWindowDockID() end


--- is current window docked into another window?
---@return bool
function _imgui.IsWindowDocked() end

--- Logging/Capture
--- - All text output from the interface can be captured into tty/file/clipboard. By default, tree nodes are automatically opened during logging.
--- start logging to tty (stdout)
---@param auto_open_depth int
---@return void
function _imgui.LogToTTY(auto_open_depth) end


--- start logging to file
---@param auto_open_depth int
---@param filename const char*
---@return void
function _imgui.LogToFile(auto_open_depth, filename) end


--- start logging to OS clipboard
---@param auto_open_depth int
---@return void
function _imgui.LogToClipboard(auto_open_depth) end


--- stop logging (close file, etc.)
---@return void
function _imgui.LogFinish() end


--- helper to display buttons for logging to tty/file/clipboard
---@return void
function _imgui.LogButtons() end


--- pass text data straight to log (without being displayed)
---@param fmt const char*
---@return void
function _imgui.LogText(fmt, ...) end


---@param fmt const char*
---@param args va_list
---@return void
function _imgui.LogTextV(fmt, args) end

--- Drag and Drop
--- - On source items, call BeginDragDropSource(), if it returns true also call SetDragDropPayload() + EndDragDropSource().
--- - On target candidates, call BeginDragDropTarget(), if it returns true also call AcceptDragDropPayload() + EndDragDropTarget().
--- - If you stop calling BeginDragDropSource() the payload is preserved however it won't have a preview tooltip (we currently display a fallback "..." tooltip, see #1725)
--- - An item can be both drag source and drop target.
--- call after submitting an item which may be dragged. when this return true, you can call SetDragDropPayload() + EndDragDropSource()
---@param flags ImGuiDragDropFlags
---@return bool
function _imgui.BeginDragDropSource(flags) end


--- type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.
---@param type const char*
---@param data const void*
---@param sz size_t
---@param cond ImGuiCond
---@return bool
function _imgui.SetDragDropPayload(type, data, sz, cond) end


--- only call EndDragDropSource() if BeginDragDropSource() returns true!
---@return void
function _imgui.EndDragDropSource() end


--- call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()
---@return bool
function _imgui.BeginDragDropTarget() end


--- accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.
---@param type const char*
---@param flags ImGuiDragDropFlags
---@return const ImGuiPayload*
function _imgui.AcceptDragDropPayload(type, flags) end


--- only call EndDragDropTarget() if BeginDragDropTarget() returns true!
---@return void
function _imgui.EndDragDropTarget() end


--- peek directly into the current payload from anywhere. may return NULL. use ImGuiPayload::IsDataType() to test for the payload type.
---@return const ImGuiPayload*
function _imgui.GetDragDropPayload() end

--- Disabling [BETA API]
--- - Disable all user interactions and dim items visuals (applying style.DisabledAlpha over current colors)
--- - Those can be nested but it cannot be used to enable an already disabled section (a single BeginDisabled(true) in the stack is enough to keep everything disabled)
--- - BeginDisabled(false) essentially does nothing useful but is provided to facilitate use of boolean expressions. If you can avoid calling BeginDisabled(False)/EndDisabled() best to avoid it.
---@param disabled bool
---@return void
function _imgui.BeginDisabled(disabled) end


---@return void
function _imgui.EndDisabled() end

--- Clipping
--- - Mouse hovering is affected by ImGui::PushClipRect() calls, unlike direct calls to ImDrawList::PushClipRect() which are render only.
---@param clip_rect_min ImVec2
---@param clip_rect_max ImVec2
---@param intersect_with_current_clip_rect bool
---@return void
function _imgui.PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect) end


---@return void
function _imgui.PopClipRect() end

--- Focus, Activation
--- - Prefer using "SetItemDefaultFocus()" over "if (IsWindowAppearing()) SetScrollHereY()" when applicable to signify "this is the default item"
--- make last item the default focused item of a window.
---@return void
function _imgui.SetItemDefaultFocus() end


--- Implied offset = 0
---@return void
function _imgui.SetKeyboardFocusHere() end


--- focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.
---@param offset int
---@return void
function _imgui.SetKeyboardFocusHereEx(offset) end

--- Item/Widgets Utilities and Query Functions
--- - Most of the functions are referring to the previous Item that has been submitted.
--- - See Demo Window under "Widgets->Querying Status" for an interactive visualization of most of those functions.
--- is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.
---@param flags ImGuiHoveredFlags
---@return bool
function _imgui.IsItemHovered(flags) end


--- is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)
---@return bool
function _imgui.IsItemActive() end


--- is the last item focused for keyboard/gamepad navigation?
---@return bool
function _imgui.IsItemFocused() end


--- Implied mouse_button = 0
---@return bool
function _imgui.IsItemClicked() end


--- is the last item hovered and mouse clicked on? (**)  == IsMouseClicked(mouse_button) && IsItemHovered()Important. (**) this it NOT equivalent to the behavior of e.g. Button(). Read comments in function definition.
---@param mouse_button ImGuiMouseButton
---@return bool
function _imgui.IsItemClickedEx(mouse_button) end


--- is the last item visible? (items may be out of sight because of clipping/scrolling)
---@return bool
function _imgui.IsItemVisible() end


--- did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.
---@return bool
function _imgui.IsItemEdited() end


--- was the last item just made active (item was previously inactive).
---@return bool
function _imgui.IsItemActivated() end


--- was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that requires continuous editing.
---@return bool
function _imgui.IsItemDeactivated() end


--- was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that requires continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).
---@return bool
function _imgui.IsItemDeactivatedAfterEdit() end


--- was the last item open state toggled? set by TreeNode().
---@return bool
function _imgui.IsItemToggledOpen() end


--- is any item hovered?
---@return bool
function _imgui.IsAnyItemHovered() end


--- is any item active?
---@return bool
function _imgui.IsAnyItemActive() end


--- is any item focused?
---@return bool
function _imgui.IsAnyItemFocused() end


--- get upper-left bounding rectangle of the last item (screen space)
---@return ImVec2
function _imgui.GetItemRectMin() end


--- get lower-right bounding rectangle of the last item (screen space)
---@return ImVec2
function _imgui.GetItemRectMax() end


--- get size of last item
---@return ImVec2
function _imgui.GetItemRectSize() end


--- allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area.
---@return void
function _imgui.SetItemAllowOverlap() end

--- Viewports
--- - Currently represents the Platform Window created by the application which is hosting our Dear ImGui windows.
--- - In 'docking' branch with multi-viewport enabled, we extend this concept to have multiple active viewports.
--- - In the future we will extend this concept further to also represent Platform Monitor and support a "no main platform window" operation mode.
--- return primary/default viewport. This can never be NULL.
---@return ImGuiViewport*
function _imgui.GetMainViewport() end

--- Background/Foreground Draw Lists
--- get background draw list for the viewport associated to the current window. this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.
---@return ImDrawList*
function _imgui.GetBackgroundDrawList() end


--- get foreground draw list for the viewport associated to the current window. this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents.
---@return ImDrawList*
function _imgui.GetForegroundDrawList() end


--- get background draw list for the given viewport. this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.
---@param viewport ImGuiViewport*
---@return ImDrawList*
function _imgui.GetBackgroundDrawListImGuiViewportPtr(viewport) end


--- get foreground draw list for the given viewport. this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents.
---@param viewport ImGuiViewport*
---@return ImDrawList*
function _imgui.GetForegroundDrawListImGuiViewportPtr(viewport) end

--- Miscellaneous Utilities
--- test if rectangle (of given size, starting from cursor position) is visible / not clipped.
---@param size ImVec2
---@return bool
function _imgui.IsRectVisibleBySize(size) end


--- test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
---@param rect_min ImVec2
---@param rect_max ImVec2
---@return bool
function _imgui.IsRectVisible(rect_min, rect_max) end


--- get global imgui time. incremented by io.DeltaTime every frame.
---@return double
function _imgui.GetTime() end


--- get global imgui frame count. incremented by 1 every frame.
---@return int
function _imgui.GetFrameCount() end


--- you may use this when creating your own ImDrawList instances.
---@return ImDrawListSharedData*
function _imgui.GetDrawListSharedData() end


--- get a string corresponding to the enum value (for display, saving, etc.).
---@param idx ImGuiCol
---@return const char*
function _imgui.GetStyleColorName(idx) end


--- replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)
---@param storage ImGuiStorage*
---@return void
function _imgui.SetStateStorage(storage) end


---@return ImGuiStorage*
function _imgui.GetStateStorage() end


--- helper to create a child window / scrolling region that looks like a normal widget frame
---@param id ImGuiID
---@param size ImVec2
---@param flags ImGuiWindowFlags
---@return bool
function _imgui.BeginChildFrame(id, size, flags) end


--- always call EndChildFrame() regardless of BeginChildFrame() return values (which indicates a collapsed/clipped window)
---@return void
function _imgui.EndChildFrame() end

--- Text Utilities
--- Implied text_end = NULL, hide_text_after_double_hash = false, wrap_width = -1.0f
---@param text const char*
---@return ImVec2
function _imgui.CalcTextSize(text) end


---@param text const char*
---@param text_end const char*
---@param hide_text_after_double_hash bool
---@param wrap_width float
---@return ImVec2
function _imgui.CalcTextSizeEx(text, text_end, hide_text_after_double_hash, wrap_width) end

--- Color Utilities
---@param in_ ImU32
---@return ImVec4
function _imgui.ColorConvertU32ToFloat4(in_) end


---@param in_ ImVec4
---@return ImU32
function _imgui.ColorConvertFloat4ToU32(in_) end


---@param r float
---@param g float
---@param b float
---@param out_h float*
---@param out_s float*
---@param out_v float*
---@return void
function _imgui.ColorConvertRGBtoHSV(r, g, b, out_h, out_s, out_v) end


---@param h float
---@param s float
---@param v float
---@param out_r float*
---@param out_g float*
---@param out_b float*
---@return void
function _imgui.ColorConvertHSVtoRGB(h, s, v, out_r, out_g, out_b) end

--- Inputs Utilities: Keyboard
--- Without IMGUI_DISABLE_OBSOLETE_KEYIO: (legacy support)
---   - For 'ImGuiKey key' you can still use your legacy native/user indices according to how your backend/engine stored them in io.KeysDown[].
--- With IMGUI_DISABLE_OBSOLETE_KEYIO: (this is the way forward)
---   - Any use of 'ImGuiKey' will assert when key < 512 will be passed, previously reserved as native/user keys indices
---   - GetKeyIndex() is pass-through and therefore deprecated (gone if IMGUI_DISABLE_OBSOLETE_KEYIO is defined)
--- is key being held.
---@param key ImGuiKey
---@return bool
function _imgui.IsKeyDown(key) end


--- Implied repeat = true
---@param key ImGuiKey
---@return bool
function _imgui.IsKeyPressed(key) end


--- was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate
---@param key ImGuiKey
---@param repeat_ bool
---@return bool
function _imgui.IsKeyPressedEx(key, repeat_) end


--- was key released (went from Down to !Down)?
---@param key ImGuiKey
---@return bool
function _imgui.IsKeyReleased(key) end


--- uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate
---@param key ImGuiKey
---@param repeat_delay float
---@param rate float
---@return int
function _imgui.GetKeyPressedAmount(key, repeat_delay, rate) end


--- [DEBUG] returns English name of the key. Those names a provided for debugging purpose and are not meant to be saved persistently not compared.
---@param key ImGuiKey
---@return const char*
function _imgui.GetKeyName(key) end


--- Override io.WantCaptureKeyboard flag next frame (said flag is left for your application to handle, typically when true it instructs your app to ignore inputs). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard"; after the next NewFrame() call.
---@param want_capture_keyboard bool
---@return void
function _imgui.SetNextFrameWantCaptureKeyboard(want_capture_keyboard) end

--- Inputs Utilities: Mouse
--- - To refer to a mouse button, you may use named enums in your code e.g. ImGuiMouseButton_Left, ImGuiMouseButton_Right.
--- - You can also use regular integer: it is forever guaranteed that 0=Left, 1=Right, 2=Middle.
--- - Dragging operations are only reported after mouse has moved a certain distance away from the initial clicking position (see 'lock_threshold' and 'io.MouseDraggingThreshold')
--- is mouse button held?
---@param button ImGuiMouseButton
---@return bool
function _imgui.IsMouseDown(button) end


--- Implied repeat = false
---@param button ImGuiMouseButton
---@return bool
function _imgui.IsMouseClicked(button) end


--- did mouse button clicked? (went from !Down to Down). Same as GetMouseClickedCount() == 1.
---@param button ImGuiMouseButton
---@param repeat_ bool
---@return bool
function _imgui.IsMouseClickedEx(button, repeat_) end


--- did mouse button released? (went from Down to !Down)
---@param button ImGuiMouseButton
---@return bool
function _imgui.IsMouseReleased(button) end


--- did mouse button double-clicked? Same as GetMouseClickedCount() == 2. (note that a double-click will also report IsMouseClicked() == true)
---@param button ImGuiMouseButton
---@return bool
function _imgui.IsMouseDoubleClicked(button) end


--- return the number of successive mouse-clicks at the time where a click happen (otherwise 0).
---@param button ImGuiMouseButton
---@return int
function _imgui.GetMouseClickedCount(button) end


--- Implied clip = true
---@param r_min ImVec2
---@param r_max ImVec2
---@return bool
function _imgui.IsMouseHoveringRect(r_min, r_max) end


--- is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focus/window ordering/popup-block.
---@param r_min ImVec2
---@param r_max ImVec2
---@param clip bool
---@return bool
function _imgui.IsMouseHoveringRectEx(r_min, r_max, clip) end


--- by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available
---@param mouse_pos const ImVec2*
---@return bool
function _imgui.IsMousePosValid(mouse_pos) end


--- [WILL OBSOLETE] is any mouse button held? This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.
---@return bool
function _imgui.IsAnyMouseDown() end


--- shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls
---@return ImVec2
function _imgui.GetMousePos() end


--- retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)
---@return ImVec2
function _imgui.GetMousePosOnOpeningCurrentPopup() end


--- is mouse dragging? (if lock_threshold < -1.0f, uses io.MouseDraggingThreshold)
---@param button ImGuiMouseButton
---@param lock_threshold float
---@return bool
function _imgui.IsMouseDragging(button, lock_threshold) end


--- return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (if lock_threshold < -1.0f, uses io.MouseDraggingThreshold)
---@param button ImGuiMouseButton
---@param lock_threshold float
---@return ImVec2
function _imgui.GetMouseDragDelta(button, lock_threshold) end


--- Implied button = 0
---@return void
function _imgui.ResetMouseDragDelta() end


---
---@param button ImGuiMouseButton
---@return void
function _imgui.ResetMouseDragDeltaEx(button) end


--- get desired cursor type, reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you
---@return ImGuiMouseCursor
function _imgui.GetMouseCursor() end


--- set desired cursor type
---@param cursor_type ImGuiMouseCursor
---@return void
function _imgui.SetMouseCursor(cursor_type) end


--- Override io.WantCaptureMouse flag next frame (said flag is left for your application to handle, typical when true it instucts your app to ignore inputs). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse;" after the next NewFrame() call.
---@param want_capture_mouse bool
---@return void
function _imgui.SetNextFrameWantCaptureMouse(want_capture_mouse) end

--- Clipboard Utilities
--- - Also see the LogToClipboard() function to capture GUI into clipboard, or easily output text data to the clipboard.
---@return const char*
function _imgui.GetClipboardText() end


---@param text const char*
---@return void
function _imgui.SetClipboardText(text) end

--- Settings/.Ini Utilities
--- - The disk functions are automatically called if io.IniFilename != NULL (default is "imgui.ini").
--- - Set io.IniFilename to NULL to load/save manually. Read io.WantSaveIniSettings description about handling .ini saving manually.
--- - Important: default value "imgui.ini" is relative to current working dir! Most apps will want to lock this to an absolute path (e.g. same path as executables).
--- call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).
---@param ini_filename const char*
---@return void
function _imgui.LoadIniSettingsFromDisk(ini_filename) end


--- call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.
---@param ini_data const char*
---@param ini_size size_t
---@return void
function _imgui.LoadIniSettingsFromMemory(ini_data, ini_size) end


--- this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).
---@param ini_filename const char*
---@return void
function _imgui.SaveIniSettingsToDisk(ini_filename) end


--- return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.
---@param out_ini_size size_t*
---@return const char*
function _imgui.SaveIniSettingsToMemory(out_ini_size) end

--- Debug Utilities
---@param text const char*
---@return void
function _imgui.DebugTextEncoding(text) end


--- This is called by IMGUI_CHECKVERSION() macro.
---@param version_str const char*
---@param sz_io size_t
---@param sz_style size_t
---@param sz_vec2 size_t
---@param sz_vec4 size_t
---@param sz_drawvert size_t
---@param sz_drawidx size_t
---@return bool
function _imgui.DebugCheckVersionAndDataLayout(version_str, sz_io, sz_style, sz_vec2, sz_vec4, sz_drawvert, sz_drawidx) end

--- Memory Allocators
--- - Those functions are not reliant on the current context.
--- - DLL users: heaps and globals are not shared across DLL boundaries! You will need to call SetCurrentContext() + SetAllocatorFunctions()
---   for each static/DLL boundary you are calling from. Read "Context and Memory Allocators" section of imgui.cpp for more details.
---@param alloc_func ImGuiMemAllocFunc
---@param free_func ImGuiMemFreeFunc
---@param user_data void*
---@return void
function _imgui.SetAllocatorFunctions(alloc_func, free_func, user_data) end


---@param p_alloc_func ImGuiMemAllocFunc*
---@param p_free_func ImGuiMemFreeFunc*
---@param p_user_data void**
---@return void
function _imgui.GetAllocatorFunctions(p_alloc_func, p_free_func, p_user_data) end


---@param size size_t
---@return void*
function _imgui.MemAlloc(size) end


---@param ptr void*
---@return void
function _imgui.MemFree(ptr) end

--- (Optional) Platform/OS interface for multi-viewport support
--- Read comments around the ImGuiPlatformIO structure for more details.
--- Note: You may use GetWindowViewport() to get the current viewport of the current window.
--- platform/renderer functions, for backend to setup + viewports list.
---@return ImGuiPlatformIO*
function _imgui.GetPlatformIO() end


--- call in main loop. will call CreateWindow/ResizeWindow/etc. platform functions for each secondary viewport, and DestroyWindow for each inactive viewport.
---@return void
function _imgui.UpdatePlatformWindows() end


--- Implied platform_render_arg = NULL, renderer_render_arg = NULL
---@return void
function _imgui.RenderPlatformWindowsDefault() end


--- call in main loop. will call RenderWindow/SwapBuffers platform functions for each secondary viewport which doesn't have the ImGuiViewportFlags_Minimized flag set. May be reimplemented by user for custom rendering needs.
---@param platform_render_arg void*
---@param renderer_render_arg void*
---@return void
function _imgui.RenderPlatformWindowsDefaultEx(platform_render_arg, renderer_render_arg) end


--- call DestroyWindow platform functions for all viewports. call from backend Shutdown() if you need to close platform windows before imgui shutdown. otherwise will be called by DestroyContext().
---@return void
function _imgui.DestroyPlatformWindows() end


--- this is a helper for backends.
---@param id ImGuiID
---@return ImGuiViewport*
function _imgui.FindViewportByID(id) end


--- this is a helper for backends. the type platform_handle is decided by the backend (e.g. HWND, MyWindow*, GLFWwindow* etc.)
---@param platform_handle void*
---@return ImGuiViewport*
function _imgui.FindViewportByPlatformHandle(platform_handle) end


--- Construct a zero-size ImVector<> (of any type). This is primarily useful when calling ImFontGlyphRangesBuilder_BuildRanges()
---@param vector void*
---@return void
function _imgui.ImVector_Construct(vector) end


--- Destruct an ImVector<> (of any type). Important: Frees the vector memory but does not call destructors on contained objects (if they have them)
---@param vector void*
---@return void
function _imgui.ImVector_Destruct(vector) end


--- Build an ImStr from a regular const char* (no data is copied, so you need to make sure the original char* isn't altered as long as you are using the ImStr).
---@param b const char*
---@return ImStr
function _imgui.ImStr_FromCharStr(b) end


---@param self ImGuiStyle*
---@param scale_factor float
---@return void
function _imgui.Style_ScaleAllSizes(self, scale_factor) end

--- Input Functions
--- Queue a new key down/up event. Key should be "translated" (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)
---@param self ImGuiIO*
---@param key ImGuiKey
---@param down bool
---@return void
function _imgui.IO_AddKeyEvent(self, key, down) end


--- Queue a new key down/up event for analog values (e.g. ImGuiKey_Gamepad_ values). Dead-zones should be handled by the backend.
---@param self ImGuiIO*
---@param key ImGuiKey
---@param down bool
---@param v float
---@return void
function _imgui.IO_AddKeyAnalogEvent(self, key, down, v) end


--- Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to signify no mouse (e.g. app not focused and not hovered)
---@param self ImGuiIO*
---@param x float
---@param y float
---@return void
function _imgui.IO_AddMousePosEvent(self, x, y) end


--- Queue a mouse button change
---@param self ImGuiIO*
---@param button int
---@param down bool
---@return void
function _imgui.IO_AddMouseButtonEvent(self, button, down) end


--- Queue a mouse wheel update
---@param self ImGuiIO*
---@param wh_x float
---@param wh_y float
---@return void
function _imgui.IO_AddMouseWheelEvent(self, wh_x, wh_y) end


--- Queue a mouse hovered viewport. Requires backend to set ImGuiBackendFlags_HasMouseHoveredViewport to call this (for multi-viewport support).
---@param self ImGuiIO*
---@param id ImGuiID
---@return void
function _imgui.IO_AddMouseViewportEvent(self, id) end


--- Queue a gain/loss of focus for the application (generally based on OS/platform focus of your window)
---@param self ImGuiIO*
---@param focused bool
---@return void
function _imgui.IO_AddFocusEvent(self, focused) end


--- Queue a new character input
---@param self ImGuiIO*
---@param c unsigned int
---@return void
function _imgui.IO_AddInputCharacter(self, c) end


--- Queue a new character input from an UTF-16 character, it can be a surrogate
---@param self ImGuiIO*
---@param c ImWchar16
---@return void
function _imgui.IO_AddInputCharacterUTF16(self, c) end


--- Queue a new characters input from an UTF-8 string
---@param self ImGuiIO*
---@param str const char*
---@return void
function _imgui.IO_AddInputCharactersUTF8(self, str) end


--- Implied native_legacy_index = -1
---@param self ImGuiIO*
---@param key ImGuiKey
---@param native_keycode int
---@param native_scancode int
---@return void
function _imgui.IO_SetKeyEventNativeData(self, key, native_keycode, native_scancode) end


--- [Optional] Specify index for legacy <1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.
---@param self ImGuiIO*
---@param key ImGuiKey
---@param native_keycode int
---@param native_scancode int
---@param native_legacy_index int
---@return void
function _imgui.IO_SetKeyEventNativeDataEx(self, key, native_keycode, native_scancode, native_legacy_index) end


--- Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.
---@param self ImGuiIO*
---@param accepting_events bool
---@return void
function _imgui.IO_SetAppAcceptingEvents(self, accepting_events) end


--- [Internal] Clear the text input buffer manually
---@param self ImGuiIO*
---@return void
function _imgui.IO_ClearInputCharacters(self) end


--- [Internal] Release all keys
---@param self ImGuiIO*
---@return void
function _imgui.IO_ClearInputKeys(self) end


---@param self ImGuiInputTextCallbackData*
---@param pos int
---@param bytes_count int
---@return void
function _imgui.InputTextCallbackData_DeleteChars(self, pos, bytes_count) end


---@param self ImGuiInputTextCallbackData*
---@param pos int
---@param text const char*
---@param text_end const char*
---@return void
function _imgui.InputTextCallbackData_InsertChars(self, pos, text, text_end) end


---@param self ImGuiInputTextCallbackData*
---@return void
function _imgui.InputTextCallbackData_SelectAll(self) end


---@param self ImGuiInputTextCallbackData*
---@return void
function _imgui.InputTextCallbackData_ClearSelection(self) end


---@param self const ImGuiInputTextCallbackData*
---@return bool
function _imgui.InputTextCallbackData_HasSelection(self) end


---@param self ImGuiPayload*
---@return void
function _imgui.Payload_Clear(self) end


---@param self const ImGuiPayload*
---@param type const char*
---@return bool
function _imgui.Payload_IsDataType(self, type) end


---@param self const ImGuiPayload*
---@return bool
function _imgui.Payload_IsPreview(self) end


---@param self const ImGuiPayload*
---@return bool
function _imgui.Payload_IsDelivery(self) end


---@param self const ImGuiTextFilter_ImGuiTextRange*
---@return bool
function _imgui.TextFilter_ImGuiTextRange_empty(self) end


---@param self const ImGuiTextFilter_ImGuiTextRange*
---@param separator char
---@param out ImVector_ImGuiTextFilter_ImGuiTextRange*
---@return void
function _imgui.TextFilter_ImGuiTextRange_split(self, separator, out) end


--- Helper calling InputText+Build
---@param self ImGuiTextFilter*
---@param label const char*
---@param width float
---@return bool
function _imgui.TextFilter_Draw(self, label, width) end


---@param self const ImGuiTextFilter*
---@param text const char*
---@param text_end const char*
---@return bool
function _imgui.TextFilter_PassFilter(self, text, text_end) end


---@param self ImGuiTextFilter*
---@return void
function _imgui.TextFilter_Build(self) end


---@param self ImGuiTextFilter*
---@return void
function _imgui.TextFilter_Clear(self) end


---@param self const ImGuiTextFilter*
---@return bool
function _imgui.TextFilter_IsActive(self) end


---@param self const ImGuiTextBuffer*
---@return const char*
function _imgui.TextBuffer_begin(self) end


--- Buf is zero-terminated, so end() will point on the zero-terminator
---@param self const ImGuiTextBuffer*
---@return const char*
function _imgui.TextBuffer_end(self) end


---@param self const ImGuiTextBuffer*
---@return int
function _imgui.TextBuffer_size(self) end


---@param self const ImGuiTextBuffer*
---@return bool
function _imgui.TextBuffer_empty(self) end


---@param self ImGuiTextBuffer*
---@return void
function _imgui.TextBuffer_clear(self) end


---@param self ImGuiTextBuffer*
---@param capacity int
---@return void
function _imgui.TextBuffer_reserve(self, capacity) end


---@param self const ImGuiTextBuffer*
---@return const char*
function _imgui.TextBuffer_c_str(self) end


---@param self ImGuiTextBuffer*
---@param str const char*
---@param str_end const char*
---@return void
function _imgui.TextBuffer_append(self, str, str_end) end


---@param self ImGuiTextBuffer*
---@param fmt const char*
---@return void
function _imgui.TextBuffer_appendf(self, fmt, ...) end


---@param self ImGuiTextBuffer*
---@param fmt const char*
---@param args va_list
---@return void
function _imgui.TextBuffer_appendfv(self, fmt, args) end

--- - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)
--- - Set***() functions find pair, insertion on demand if missing.
--- - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.
---@param self ImGuiStorage*
---@return void
function _imgui.Storage_Clear(self) end


---@param self const ImGuiStorage*
---@param key ImGuiID
---@param default_val int
---@return int
function _imgui.Storage_GetInt(self, key, default_val) end


---@param self ImGuiStorage*
---@param key ImGuiID
---@param val int
---@return void
function _imgui.Storage_SetInt(self, key, val) end


---@param self const ImGuiStorage*
---@param key ImGuiID
---@param default_val bool
---@return bool
function _imgui.Storage_GetBool(self, key, default_val) end


---@param self ImGuiStorage*
---@param key ImGuiID
---@param val bool
---@return void
function _imgui.Storage_SetBool(self, key, val) end


---@param self const ImGuiStorage*
---@param key ImGuiID
---@param default_val float
---@return float
function _imgui.Storage_GetFloat(self, key, default_val) end


---@param self ImGuiStorage*
---@param key ImGuiID
---@param val float
---@return void
function _imgui.Storage_SetFloat(self, key, val) end


--- default_val is NULL
---@param self const ImGuiStorage*
---@param key ImGuiID
---@return void*
function _imgui.Storage_GetVoidPtr(self, key) end


---@param self ImGuiStorage*
---@param key ImGuiID
---@param val void*
---@return void
function _imgui.Storage_SetVoidPtr(self, key, val) end

--- - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.
--- - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
--- - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)
---      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat("var", pvar, 0, 100.0f); some_var += *pvar;
---@param self ImGuiStorage*
---@param key ImGuiID
---@param default_val int
---@return int*
function _imgui.Storage_GetIntRef(self, key, default_val) end


---@param self ImGuiStorage*
---@param key ImGuiID
---@param default_val bool
---@return bool*
function _imgui.Storage_GetBoolRef(self, key, default_val) end


---@param self ImGuiStorage*
---@param key ImGuiID
---@param default_val float
---@return float*
function _imgui.Storage_GetFloatRef(self, key, default_val) end


---@param self ImGuiStorage*
---@param key ImGuiID
---@param default_val void*
---@return void**
function _imgui.Storage_GetVoidPtrRef(self, key, default_val) end

--- Use on your own storage if you know only integer are being stored (open/close all tree nodes)
---@param self ImGuiStorage*
---@param val int
---@return void
function _imgui.Storage_SetAllInt(self, val) end

--- For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
---@param self ImGuiStorage*
---@return void
function _imgui.Storage_BuildSortByKey(self) end


---@param self ImGuiListClipper*
---@param items_count int
---@param items_height float
---@return void
function _imgui.ListClipper_Begin(self, items_count, items_height) end


--- Automatically called on the last call of Step() that returns false.
---@param self ImGuiListClipper*
---@return void
function _imgui.ListClipper_End(self) end


--- Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.
---@param self ImGuiListClipper*
---@return bool
function _imgui.ListClipper_Step(self) end

--- Call ForceDisplayRangeByIndices() before first call to Step() if you need a range of items to be displayed regardless of visibility.
--- item_max is exclusive e.g. use (42, 42+1) to make item 42 always visible BUT due to alignment/padding of certain items it is likely that an extra item may be included on either end of the display range.
---@param self ImGuiListClipper*
---@param item_min int
---@param item_max int
---@return void
function _imgui.ListClipper_ForceDisplayRangeByIndices(self, item_min, item_max) end

--- FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.
---@param self ImColor*
---@param h float
---@param s float
---@param v float
---@param a float
---@return void
function _imgui.ImColor_SetHSV(self, h, s, v, a) end


---@param self ImColor*
---@param h float
---@param s float
---@param v float
---@param a float
---@return ImColor
function _imgui.ImColor_HSV(self, h, s, v, a) end

--- Since 1.83: returns ImTextureID associated with this draw call. Warning: DO NOT assume this is always same as 'TextureId' (we will change this function for an upcoming feature)
---@param self const ImDrawCmd*
---@return ImTextureID
function _imgui.ImDrawCmd_GetTexID(self) end


--- Do not clear Channels[] so our allocations are reused next frame
---@param self ImDrawListSplitter*
---@return void
function _imgui.ImDrawListSplitter_Clear(self) end


---@param self ImDrawListSplitter*
---@return void
function _imgui.ImDrawListSplitter_ClearFreeMemory(self) end


---@param self ImDrawListSplitter*
---@param draw_list ImDrawList*
---@param count int
---@return void
function _imgui.ImDrawListSplitter_Split(self, draw_list, count) end


---@param self ImDrawListSplitter*
---@param draw_list ImDrawList*
---@return void
function _imgui.ImDrawListSplitter_Merge(self, draw_list) end


---@param self ImDrawListSplitter*
---@param draw_list ImDrawList*
---@param channel_idx int
---@return void
function _imgui.ImDrawListSplitter_SetCurrentChannel(self, draw_list, channel_idx) end


--- Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
---@param self ImDrawList*
---@param clip_rect_min ImVec2
---@param clip_rect_max ImVec2
---@param intersect_with_current_clip_rect bool
---@return void
function _imgui.ImDrawList_PushClipRect(self, clip_rect_min, clip_rect_max, intersect_with_current_clip_rect) end


---@param self ImDrawList*
---@return void
function _imgui.ImDrawList_PushClipRectFullScreen(self) end


---@param self ImDrawList*
---@return void
function _imgui.ImDrawList_PopClipRect(self) end


---@param self ImDrawList*
---@param texture_id ImTextureID
---@return void
function _imgui.ImDrawList_PushTextureID(self, texture_id) end


---@param self ImDrawList*
---@return void
function _imgui.ImDrawList_PopTextureID(self) end


---@param self const ImDrawList*
---@return ImVec2
function _imgui.ImDrawList_GetClipRectMin(self) end


---@param self const ImDrawList*
---@return ImVec2
function _imgui.ImDrawList_GetClipRectMax(self) end

--- Primitives
--- - Filled shapes must always use clockwise winding order. The anti-aliasing fringe depends on it. Counter-clockwise shapes will have "inward" anti-aliasing.
--- - For rectangular primitives, "p_min" and "p_max" represent the upper-left and lower-right corners.
--- - For circle primitives, use "num_segments == 0" to automatically calculate tessellation (preferred).
---   In older versions (until Dear ImGui 1.77) the AddCircle functions defaulted to num_segments == 12.
---   In future versions we will use textures to provide cheaper and higher-quality circles.
---   Use AddNgon() and AddNgonFilled() functions if you need to guaranteed a specific number of sides.
--- Implied thickness = 1.0f
---@param self ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param col ImU32
---@return void
function _imgui.ImDrawList_AddLine(self, p1, p2, col) end


---@param self ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param col ImU32
---@param thickness float
---@return void
function _imgui.ImDrawList_AddLineEx(self, p1, p2, col, thickness) end


--- Implied rounding = 0.0f, flags = 0, thickness = 1.0f
---@param self ImDrawList*
---@param p_min ImVec2
---@param p_max ImVec2
---@param col ImU32
---@return void
function _imgui.ImDrawList_AddRect(self, p_min, p_max, col) end


--- a: upper-left, b: lower-right (== upper-left + size)
---@param self ImDrawList*
---@param p_min ImVec2
---@param p_max ImVec2
---@param col ImU32
---@param rounding float
---@param flags ImDrawFlags
---@param thickness float
---@return void
function _imgui.ImDrawList_AddRectEx(self, p_min, p_max, col, rounding, flags, thickness) end


--- Implied rounding = 0.0f, flags = 0
---@param self ImDrawList*
---@param p_min ImVec2
---@param p_max ImVec2
---@param col ImU32
---@return void
function _imgui.ImDrawList_AddRectFilled(self, p_min, p_max, col) end


--- a: upper-left, b: lower-right (== upper-left + size)
---@param self ImDrawList*
---@param p_min ImVec2
---@param p_max ImVec2
---@param col ImU32
---@param rounding float
---@param flags ImDrawFlags
---@return void
function _imgui.ImDrawList_AddRectFilledEx(self, p_min, p_max, col, rounding, flags) end


---@param self ImDrawList*
---@param p_min ImVec2
---@param p_max ImVec2
---@param col_upr_left ImU32
---@param col_upr_right ImU32
---@param col_bot_right ImU32
---@param col_bot_left ImU32
---@return void
function _imgui.ImDrawList_AddRectFilledMultiColor(self, p_min, p_max, col_upr_left, col_upr_right, col_bot_right, col_bot_left) end


--- Implied thickness = 1.0f
---@param self ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param col ImU32
---@return void
function _imgui.ImDrawList_AddQuad(self, p1, p2, p3, p4, col) end


---@param self ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param col ImU32
---@param thickness float
---@return void
function _imgui.ImDrawList_AddQuadEx(self, p1, p2, p3, p4, col, thickness) end


---@param self ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param col ImU32
---@return void
function _imgui.ImDrawList_AddQuadFilled(self, p1, p2, p3, p4, col) end


--- Implied thickness = 1.0f
---@param self ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param col ImU32
---@return void
function _imgui.ImDrawList_AddTriangle(self, p1, p2, p3, col) end


---@param self ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param col ImU32
---@param thickness float
---@return void
function _imgui.ImDrawList_AddTriangleEx(self, p1, p2, p3, col, thickness) end


---@param self ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param col ImU32
---@return void
function _imgui.ImDrawList_AddTriangleFilled(self, p1, p2, p3, col) end


--- Implied num_segments = 0, thickness = 1.0f
---@param self ImDrawList*
---@param center ImVec2
---@param radius float
---@param col ImU32
---@return void
function _imgui.ImDrawList_AddCircle(self, center, radius, col) end


---@param self ImDrawList*
---@param center ImVec2
---@param radius float
---@param col ImU32
---@param num_segments int
---@param thickness float
---@return void
function _imgui.ImDrawList_AddCircleEx(self, center, radius, col, num_segments, thickness) end


---@param self ImDrawList*
---@param center ImVec2
---@param radius float
---@param col ImU32
---@param num_segments int
---@return void
function _imgui.ImDrawList_AddCircleFilled(self, center, radius, col, num_segments) end


--- Implied thickness = 1.0f
---@param self ImDrawList*
---@param center ImVec2
---@param radius float
---@param col ImU32
---@param num_segments int
---@return void
function _imgui.ImDrawList_AddNgon(self, center, radius, col, num_segments) end


---@param self ImDrawList*
---@param center ImVec2
---@param radius float
---@param col ImU32
---@param num_segments int
---@param thickness float
---@return void
function _imgui.ImDrawList_AddNgonEx(self, center, radius, col, num_segments, thickness) end


---@param self ImDrawList*
---@param center ImVec2
---@param radius float
---@param col ImU32
---@param num_segments int
---@return void
function _imgui.ImDrawList_AddNgonFilled(self, center, radius, col, num_segments) end


--- Implied text_end = NULL
---@param self ImDrawList*
---@param pos ImVec2
---@param col ImU32
---@param text_begin const char*
---@return void
function _imgui.ImDrawList_AddText(self, pos, col, text_begin) end


---@param self ImDrawList*
---@param pos ImVec2
---@param col ImU32
---@param text_begin const char*
---@param text_end const char*
---@return void
function _imgui.ImDrawList_AddTextEx(self, pos, col, text_begin, text_end) end


--- Implied text_end = NULL, wrap_width = 0.0f, cpu_fine_clip_rect = NULL
---@param self ImDrawList*
---@param font const ImFont*
---@param font_size float
---@param pos ImVec2
---@param col ImU32
---@param text_begin const char*
---@return void
function _imgui.ImDrawList_AddTextImFontPtr(self, font, font_size, pos, col, text_begin) end


---@param self ImDrawList*
---@param font const ImFont*
---@param font_size float
---@param pos ImVec2
---@param col ImU32
---@param text_begin const char*
---@param text_end const char*
---@param wrap_width float
---@param cpu_fine_clip_rect const ImVec4*
---@return void
function _imgui.ImDrawList_AddTextImFontPtrEx(self, font, font_size, pos, col, text_begin, text_end, wrap_width, cpu_fine_clip_rect) end


---@param self ImDrawList*
---@param points const ImVec2*
---@param num_points int
---@param col ImU32
---@param flags ImDrawFlags
---@param thickness float
---@return void
function _imgui.ImDrawList_AddPolyline(self, points, num_points, col, flags, thickness) end


---@param self ImDrawList*
---@param points const ImVec2*
---@param num_points int
---@param col ImU32
---@return void
function _imgui.ImDrawList_AddConvexPolyFilled(self, points, num_points, col) end


--- Cubic Bezier (4 control points)
---@param self ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param col ImU32
---@param thickness float
---@param num_segments int
---@return void
function _imgui.ImDrawList_AddBezierCubic(self, p1, p2, p3, p4, col, thickness, num_segments) end


--- Quadratic Bezier (3 control points)
---@param self ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param col ImU32
---@param thickness float
---@param num_segments int
---@return void
function _imgui.ImDrawList_AddBezierQuadratic(self, p1, p2, p3, col, thickness, num_segments) end

--- Image primitives
--- - Read FAQ to understand what ImTextureID is.
--- - "p_min" and "p_max" represent the upper-left and lower-right corners of the rectangle.
--- - "uv_min" and "uv_max" represent the normalized texture coordinates to use for those corners. Using (0,0)->(1,1) texture coordinates will generally display the entire texture.
--- Implied uv_min = ImVec2(0, 0), uv_max = ImVec2(1, 1), col = IM_COL32_WHITE
---@param self ImDrawList*
---@param user_texture_id ImTextureID
---@param p_min ImVec2
---@param p_max ImVec2
---@return void
function _imgui.ImDrawList_AddImage(self, user_texture_id, p_min, p_max) end


---@param self ImDrawList*
---@param user_texture_id ImTextureID
---@param p_min ImVec2
---@param p_max ImVec2
---@param uv_min ImVec2
---@param uv_max ImVec2
---@param col ImU32
---@return void
function _imgui.ImDrawList_AddImageEx(self, user_texture_id, p_min, p_max, uv_min, uv_max, col) end


--- Implied uv1 = ImVec2(0, 0), uv2 = ImVec2(1, 0), uv3 = ImVec2(1, 1), uv4 = ImVec2(0, 1), col = IM_COL32_WHITE
---@param self ImDrawList*
---@param user_texture_id ImTextureID
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@return void
function _imgui.ImDrawList_AddImageQuad(self, user_texture_id, p1, p2, p3, p4) end


---@param self ImDrawList*
---@param user_texture_id ImTextureID
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param uv1 ImVec2
---@param uv2 ImVec2
---@param uv3 ImVec2
---@param uv4 ImVec2
---@param col ImU32
---@return void
function _imgui.ImDrawList_AddImageQuadEx(self, user_texture_id, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col) end


---@param self ImDrawList*
---@param user_texture_id ImTextureID
---@param p_min ImVec2
---@param p_max ImVec2
---@param uv_min ImVec2
---@param uv_max ImVec2
---@param col ImU32
---@param rounding float
---@param flags ImDrawFlags
---@return void
function _imgui.ImDrawList_AddImageRounded(self, user_texture_id, p_min, p_max, uv_min, uv_max, col, rounding, flags) end

--- Stateful path API, add points then finish with PathFillConvex() or PathStroke()
--- - Filled shapes must always use clockwise winding order. The anti-aliasing fringe depends on it. Counter-clockwise shapes will have "inward" anti-aliasing.
---@param self ImDrawList*
---@return void
function _imgui.ImDrawList_PathClear(self) end


---@param self ImDrawList*
---@param pos ImVec2
---@return void
function _imgui.ImDrawList_PathLineTo(self, pos) end


---@param self ImDrawList*
---@param pos ImVec2
---@return void
function _imgui.ImDrawList_PathLineToMergeDuplicate(self, pos) end


---@param self ImDrawList*
---@param col ImU32
---@return void
function _imgui.ImDrawList_PathFillConvex(self, col) end


---@param self ImDrawList*
---@param col ImU32
---@param flags ImDrawFlags
---@param thickness float
---@return void
function _imgui.ImDrawList_PathStroke(self, col, flags, thickness) end


---@param self ImDrawList*
---@param center ImVec2
---@param radius float
---@param a_min float
---@param a_max float
---@param num_segments int
---@return void
function _imgui.ImDrawList_PathArcTo(self, center, radius, a_min, a_max, num_segments) end


--- Use precomputed angles for a 12 steps circle
---@param self ImDrawList*
---@param center ImVec2
---@param radius float
---@param a_min_of_12 int
---@param a_max_of_12 int
---@return void
function _imgui.ImDrawList_PathArcToFast(self, center, radius, a_min_of_12, a_max_of_12) end


--- Cubic Bezier (4 control points)
---@param self ImDrawList*
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param num_segments int
---@return void
function _imgui.ImDrawList_PathBezierCubicCurveTo(self, p2, p3, p4, num_segments) end


--- Quadratic Bezier (3 control points)
---@param self ImDrawList*
---@param p2 ImVec2
---@param p3 ImVec2
---@param num_segments int
---@return void
function _imgui.ImDrawList_PathBezierQuadraticCurveTo(self, p2, p3, num_segments) end


---@param self ImDrawList*
---@param rect_min ImVec2
---@param rect_max ImVec2
---@param rounding float
---@param flags ImDrawFlags
---@return void
function _imgui.ImDrawList_PathRect(self, rect_min, rect_max, rounding, flags) end

--- Advanced
--- Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.
---@param self ImDrawList*
---@param callback ImDrawCallback
---@param callback_data void*
---@return void
function _imgui.ImDrawList_AddCallback(self, callback, callback_data) end


--- This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible
---@param self ImDrawList*
---@return void
function _imgui.ImDrawList_AddDrawCmd(self) end


--- Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.
---@param self const ImDrawList*
---@return ImDrawList*
function _imgui.ImDrawList_CloneOutput(self) end

--- Advanced: Channels
--- - Use to split render into layers. By switching channels to can render out-of-order (e.g. submit FG primitives before BG primitives)
--- - Use to minimize draw calls (e.g. if going back-and-forth between multiple clipping rectangles, prefer to append into separate channels then merge at the end)
--- - FIXME-OBSOLETE: This API shouldn't have been in ImDrawList in the first place!
---   Prefer using your own persistent instance of ImDrawListSplitter as you can stack them.
---   Using the ImDrawList::ChannelsXXXX you cannot stack a split over another.
---@param self ImDrawList*
---@param count int
---@return void
function _imgui.ImDrawList_ChannelsSplit(self, count) end


---@param self ImDrawList*
---@return void
function _imgui.ImDrawList_ChannelsMerge(self) end


---@param self ImDrawList*
---@param n int
---@return void
function _imgui.ImDrawList_ChannelsSetCurrent(self, n) end

--- Advanced: Primitives allocations
--- - We render triangles (three vertices)
--- - All primitives needs to be reserved via PrimReserve() beforehand.
---@param self ImDrawList*
---@param idx_count int
---@param vtx_count int
---@return void
function _imgui.ImDrawList_PrimReserve(self, idx_count, vtx_count) end


---@param self ImDrawList*
---@param idx_count int
---@param vtx_count int
---@return void
function _imgui.ImDrawList_PrimUnreserve(self, idx_count, vtx_count) end


--- Axis aligned rectangle (composed of two triangles)
---@param self ImDrawList*
---@param a ImVec2
---@param b ImVec2
---@param col ImU32
---@return void
function _imgui.ImDrawList_PrimRect(self, a, b, col) end


---@param self ImDrawList*
---@param a ImVec2
---@param b ImVec2
---@param uv_a ImVec2
---@param uv_b ImVec2
---@param col ImU32
---@return void
function _imgui.ImDrawList_PrimRectUV(self, a, b, uv_a, uv_b, col) end


---@param self ImDrawList*
---@param a ImVec2
---@param b ImVec2
---@param c ImVec2
---@param d ImVec2
---@param uv_a ImVec2
---@param uv_b ImVec2
---@param uv_c ImVec2
---@param uv_d ImVec2
---@param col ImU32
---@return void
function _imgui.ImDrawList_PrimQuadUV(self, a, b, c, d, uv_a, uv_b, uv_c, uv_d, col) end


---@param self ImDrawList*
---@param pos ImVec2
---@param uv ImVec2
---@param col ImU32
---@return void
function _imgui.ImDrawList_PrimWriteVtx(self, pos, uv, col) end


---@param self ImDrawList*
---@param idx ImDrawIdx
---@return void
function _imgui.ImDrawList_PrimWriteIdx(self, idx) end


--- Write vertex with unique index
---@param self ImDrawList*
---@param pos ImVec2
---@param uv ImVec2
---@param col ImU32
---@return void
function _imgui.ImDrawList_PrimVtx(self, pos, uv, col) end


--- OBSOLETED in 1.80 (Jan 2021)
---@param self ImDrawList*
---@param p1 ImVec2
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param col ImU32
---@param thickness float
---@param num_segments int
---@return void
function _imgui.ImDrawList_AddBezierCurve(self, p1, p2, p3, p4, col, thickness, num_segments) end


--- OBSOLETED in 1.80 (Jan 2021)
---@param self ImDrawList*
---@param p2 ImVec2
---@param p3 ImVec2
---@param p4 ImVec2
---@param num_segments int
---@return void
function _imgui.ImDrawList_PathBezierCurveTo(self, p2, p3, p4, num_segments) end

--- [Internal helpers]
---@param self ImDrawList*
---@return void
function _imgui.ImDrawList__ResetForNewFrame(self) end


---@param self ImDrawList*
---@return void
function _imgui.ImDrawList__ClearFreeMemory(self) end


---@param self ImDrawList*
---@return void
function _imgui.ImDrawList__PopUnusedDrawCmd(self) end


---@param self ImDrawList*
---@return void
function _imgui.ImDrawList__TryMergeDrawCmds(self) end


---@param self ImDrawList*
---@return void
function _imgui.ImDrawList__OnChangedClipRect(self) end


---@param self ImDrawList*
---@return void
function _imgui.ImDrawList__OnChangedTextureID(self) end


---@param self ImDrawList*
---@return void
function _imgui.ImDrawList__OnChangedVtxOffset(self) end


---@param self const ImDrawList*
---@param radius float
---@return int
function _imgui.ImDrawList__CalcCircleAutoSegmentCount(self, radius) end


---@param self ImDrawList*
---@param center ImVec2
---@param radius float
---@param a_min_sample int
---@param a_max_sample int
---@param a_step int
---@return void
function _imgui.ImDrawList__PathArcToFastEx(self, center, radius, a_min_sample, a_max_sample, a_step) end


---@param self ImDrawList*
---@param center ImVec2
---@param radius float
---@param a_min float
---@param a_max float
---@param num_segments int
---@return void
function _imgui.ImDrawList__PathArcToN(self, center, radius, a_min, a_max, num_segments) end


--- The ImDrawList are owned by ImGuiContext!
---@param self ImDrawData*
---@return void
function _imgui.ImDrawData_Clear(self) end


--- Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
---@param self ImDrawData*
---@return void
function _imgui.ImDrawData_DeIndexAllBuffers(self) end


--- Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than Dear ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
---@param self ImDrawData*
---@param fb_scale ImVec2
---@return void
function _imgui.ImDrawData_ScaleClipRects(self, fb_scale) end


---@param self ImFontGlyphRangesBuilder*
---@return void
function _imgui.ImFontGlyphRangesBuilder_Clear(self) end


--- Get bit n in the array
---@param self const ImFontGlyphRangesBuilder*
---@param n size_t
---@return bool
function _imgui.ImFontGlyphRangesBuilder_GetBit(self, n) end


--- Set bit n in the array
---@param self ImFontGlyphRangesBuilder*
---@param n size_t
---@return void
function _imgui.ImFontGlyphRangesBuilder_SetBit(self, n) end


--- Add character
---@param self ImFontGlyphRangesBuilder*
---@param c ImWchar
---@return void
function _imgui.ImFontGlyphRangesBuilder_AddChar(self, c) end


--- Add string (each character of the UTF-8 string are added)
---@param self ImFontGlyphRangesBuilder*
---@param text const char*
---@param text_end const char*
---@return void
function _imgui.ImFontGlyphRangesBuilder_AddText(self, text, text_end) end


--- Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCII/Latin+Ext
---@param self ImFontGlyphRangesBuilder*
---@param ranges const ImWchar*
---@return void
function _imgui.ImFontGlyphRangesBuilder_AddRanges(self, ranges) end


--- Output new ranges (ImVector_Construct()/ImVector_Destruct() can be used to safely construct out_ranges)
---@param self ImFontGlyphRangesBuilder*
---@param out_ranges ImVector_ImWchar*
---@return void
function _imgui.ImFontGlyphRangesBuilder_BuildRanges(self, out_ranges) end


---@param self const ImFontAtlasCustomRect*
---@return bool
function _imgui.ImFontAtlasCustomRect_IsPacked(self) end


---@param self ImFontAtlas*
---@param font_cfg const ImFontConfig*
---@return ImFont*
function _imgui.ImFontAtlas_AddFont(self, font_cfg) end


---@param self ImFontAtlas*
---@param font_cfg const ImFontConfig*
---@return ImFont*
function _imgui.ImFontAtlas_AddFontDefault(self, font_cfg) end


---@param self ImFontAtlas*
---@param filename const char*
---@param size_pixels float
---@param font_cfg const ImFontConfig*
---@param glyph_ranges const ImWchar*
---@return ImFont*
function _imgui.ImFontAtlas_AddFontFromFileTTF(self, filename, size_pixels, font_cfg, glyph_ranges) end


--- Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.
---@param self ImFontAtlas*
---@param font_data void*
---@param font_size int
---@param size_pixels float
---@param font_cfg const ImFontConfig*
---@param glyph_ranges const ImWchar*
---@return ImFont*
function _imgui.ImFontAtlas_AddFontFromMemoryTTF(self, font_data, font_size, size_pixels, font_cfg, glyph_ranges) end


--- 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
---@param self ImFontAtlas*
---@param compressed_font_data const void*
---@param compressed_font_size int
---@param size_pixels float
---@param font_cfg const ImFontConfig*
---@param glyph_ranges const ImWchar*
---@return ImFont*
function _imgui.ImFontAtlas_AddFontFromMemoryCompressedTTF(self, compressed_font_data, compressed_font_size, size_pixels, font_cfg, glyph_ranges) end


--- 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
---@param self ImFontAtlas*
---@param compressed_font_data_base85 const char*
---@param size_pixels float
---@param font_cfg const ImFontConfig*
---@param glyph_ranges const ImWchar*
---@return ImFont*
function _imgui.ImFontAtlas_AddFontFromMemoryCompressedBase85TTF(self, compressed_font_data_base85, size_pixels, font_cfg, glyph_ranges) end


--- Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.
---@param self ImFontAtlas*
---@return void
function _imgui.ImFontAtlas_ClearInputData(self) end


--- Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.
---@param self ImFontAtlas*
---@return void
function _imgui.ImFontAtlas_ClearTexData(self) end


--- Clear output font data (glyphs storage, UV coordinates).
---@param self ImFontAtlas*
---@return void
function _imgui.ImFontAtlas_ClearFonts(self) end


--- Clear all input and output.
---@param self ImFontAtlas*
---@return void
function _imgui.ImFontAtlas_Clear(self) end

--- Build atlas, retrieve pixel data.
--- User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().
--- The pitch is always = Width * BytesPerPixels (1 or 4)
--- Building in RGBA32 format is provided for convenience and compatibility, but note that unless you manually manipulate or copy color data into
--- the texture (e.g. when using the AddCustomRect*** api), then the RGB pixels emitted will always be white (~75% of memory/bandwidth waste.
--- Build pixels data. This is called automatically for you by the GetTexData*** functions.
---@param self ImFontAtlas*
---@return bool
function _imgui.ImFontAtlas_Build(self) end


--- 1 byte per-pixel
---@param self ImFontAtlas*
---@param out_pixels unsigned char**
---@param out_width int*
---@param out_height int*
---@param out_bytes_per_pixel int*
---@return void
function _imgui.ImFontAtlas_GetTexDataAsAlpha8(self, out_pixels, out_width, out_height, out_bytes_per_pixel) end


--- 4 bytes-per-pixel
---@param self ImFontAtlas*
---@param out_pixels unsigned char**
---@param out_width int*
---@param out_height int*
---@param out_bytes_per_pixel int*
---@return void
function _imgui.ImFontAtlas_GetTexDataAsRGBA32(self, out_pixels, out_width, out_height, out_bytes_per_pixel) end


--- Bit ambiguous: used to detect when user didn't built texture but effectively we should check TexID != 0 except that would be backend dependent...
---@param self const ImFontAtlas*
---@return bool
function _imgui.ImFontAtlas_IsBuilt(self) end


---@param self ImFontAtlas*
---@param id ImTextureID
---@return void
function _imgui.ImFontAtlas_SetTexID(self, id) end

--- Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)
--- NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8"Hello world" syntax. See FAQ for details.
--- NB: Consider using ImFontGlyphRangesBuilder to build glyph ranges from textual data.
--- Basic Latin, Extended Latin
---@param self ImFontAtlas*
---@return const ImWchar*
function _imgui.ImFontAtlas_GetGlyphRangesDefault(self) end


--- Default + Korean characters
---@param self ImFontAtlas*
---@return const ImWchar*
function _imgui.ImFontAtlas_GetGlyphRangesKorean(self) end


--- Default + Hiragana, Katakana, Half-Width, Selection of 2999 Ideographs
---@param self ImFontAtlas*
---@return const ImWchar*
function _imgui.ImFontAtlas_GetGlyphRangesJapanese(self) end


--- Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs
---@param self ImFontAtlas*
---@return const ImWchar*
function _imgui.ImFontAtlas_GetGlyphRangesChineseFull(self) end


--- Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese
---@param self ImFontAtlas*
---@return const ImWchar*
function _imgui.ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon(self) end


--- Default + about 400 Cyrillic characters
---@param self ImFontAtlas*
---@return const ImWchar*
function _imgui.ImFontAtlas_GetGlyphRangesCyrillic(self) end


--- Default + Thai characters
---@param self ImFontAtlas*
---@return const ImWchar*
function _imgui.ImFontAtlas_GetGlyphRangesThai(self) end


--- Default + Vietnamese characters
---@param self ImFontAtlas*
---@return const ImWchar*
function _imgui.ImFontAtlas_GetGlyphRangesVietnamese(self) end

--- You can request arbitrary rectangles to be packed into the atlas, for your own purposes.
--- - After calling Build(), you can query the rectangle position and render your pixels.
--- - If you render colored output, set 'atlas->TexPixelsUseColors = true' as this may help some backends decide of prefered texture format.
--- - You can also request your rectangles to be mapped as font glyph (given a font + Unicode point),
---   so you can render e.g. custom colorful icons and use them as regular glyphs.
--- - Read docs/FONTS.md for more details about using colorful icons.
--- - Note: this API may be redesigned later in order to support multi-monitor varying DPI settings.
---@param self ImFontAtlas*
---@param width int
---@param height int
---@return int
function _imgui.ImFontAtlas_AddCustomRectRegular(self, width, height) end


---@param self ImFontAtlas*
---@param font ImFont*
---@param id ImWchar
---@param width int
---@param height int
---@param advance_x float
---@param offset ImVec2
---@return int
function _imgui.ImFontAtlas_AddCustomRectFontGlyph(self, font, id, width, height, advance_x, offset) end


---@param self ImFontAtlas*
---@param index int
---@return ImFontAtlasCustomRect*
function _imgui.ImFontAtlas_GetCustomRectByIndex(self, index) end

--- [Internal]
---@param self const ImFontAtlas*
---@param rect const ImFontAtlasCustomRect*
---@param out_uv_min ImVec2*
---@param out_uv_max ImVec2*
---@return void
function _imgui.ImFontAtlas_CalcCustomRectUV(self, rect, out_uv_min, out_uv_max) end


---@param self ImFontAtlas*
---@param cursor ImGuiMouseCursor
---@param out_offset ImVec2*
---@param out_size ImVec2*
---@param out_uv_border ImVec2
---@param out_uv_fill ImVec2
---@return bool
function _imgui.ImFontAtlas_GetMouseCursorTexData(self, cursor, out_offset, out_size, out_uv_border, out_uv_fill) end


---@param self const ImFont*
---@param c ImWchar
---@return const ImFontGlyph*
function _imgui.ImFont_FindGlyph(self, c) end


---@param self const ImFont*
---@param c ImWchar
---@return const ImFontGlyph*
function _imgui.ImFont_FindGlyphNoFallback(self, c) end


---@param self const ImFont*
---@param c ImWchar
---@return float
function _imgui.ImFont_GetCharAdvance(self, c) end


---@param self const ImFont*
---@return bool
function _imgui.ImFont_IsLoaded(self) end


---@param self const ImFont*
---@return const char*
function _imgui.ImFont_GetDebugName(self) end

--- 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.
--- 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.
--- Implied text_end = NULL, remaining = NULL
---@param self const ImFont*
---@param size float
---@param max_width float
---@param wrap_width float
---@param text_begin const char*
---@return ImVec2
function _imgui.ImFont_CalcTextSizeA(self, size, max_width, wrap_width, text_begin) end


--- utf8
---@param self const ImFont*
---@param size float
---@param max_width float
---@param wrap_width float
---@param text_begin const char*
---@param text_end const char*
---@param remaining const char**
---@return ImVec2
function _imgui.ImFont_CalcTextSizeAEx(self, size, max_width, wrap_width, text_begin, text_end, remaining) end


---@param self const ImFont*
---@param scale float
---@param text const char*
---@param text_end const char*
---@param wrap_width float
---@return const char*
function _imgui.ImFont_CalcWordWrapPositionA(self, scale, text, text_end, wrap_width) end


---@param self const ImFont*
---@param draw_list ImDrawList*
---@param size float
---@param pos ImVec2
---@param col ImU32
---@param c ImWchar
---@return void
function _imgui.ImFont_RenderChar(self, draw_list, size, pos, col, c) end


---@param self const ImFont*
---@param draw_list ImDrawList*
---@param size float
---@param pos ImVec2
---@param col ImU32
---@param clip_rect ImVec4
---@param text_begin const char*
---@param text_end const char*
---@param wrap_width float
---@param cpu_fine_clip bool
---@return void
function _imgui.ImFont_RenderText(self, draw_list, size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip) end

--- [Internal] Don't use!
---@param self ImFont*
---@return void
function _imgui.ImFont_BuildLookupTable(self) end


---@param self ImFont*
---@return void
function _imgui.ImFont_ClearOutputData(self) end


---@param self ImFont*
---@param new_size int
---@return void
function _imgui.ImFont_GrowIndex(self, new_size) end


---@param self ImFont*
---@param src_cfg const ImFontConfig*
---@param c ImWchar
---@param x0 float
---@param y0 float
---@param x1 float
---@param y1 float
---@param u0 float
---@param v0 float
---@param u1 float
---@param v1 float
---@param advance_x float
---@return void
function _imgui.ImFont_AddGlyph(self, src_cfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advance_x) end


--- Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.
---@param self ImFont*
---@param dst ImWchar
---@param src ImWchar
---@param overwrite_dst bool
---@return void
function _imgui.ImFont_AddRemapChar(self, dst, src, overwrite_dst) end


---@param self ImFont*
---@param c ImWchar
---@param visible bool
---@return void
function _imgui.ImFont_SetGlyphVisible(self, c, visible) end


---@param self ImFont*
---@param c_begin unsigned int
---@param c_last unsigned int
---@return bool
function _imgui.ImFont_IsGlyphRangeUnused(self, c_begin, c_last) end

--- Helpers
---@param self const ImGuiViewport*
---@return ImVec2
function _imgui.Viewport_GetCenter(self) end


---@param self const ImGuiViewport*
---@return ImVec2
function _imgui.Viewport_GetWorkCenter(self) end


--- map ImGuiKey_* values into legacy native key index. == io.KeyMap[key]
---@param key ImGuiKey
---@return int
function _imgui.GetKeyIndex(key) end


---@param key ImGuiKey
---@return int
function _imgui.GetKeyIndex(key) end

--- OBSOLETED in 1.89 (from August 2022)
--- Use new ImageButton() signature (explicit item id, regular FramePadding)
---@param user_texture_id ImTextureID
---@param size ImVec2
---@param uv0 ImVec2
---@param uv1 ImVec2
---@param frame_padding int
---@param bg_col ImVec4
---@param tint_col ImVec4
---@return bool
function _imgui.ImageButtonImTextureID(user_texture_id, size, uv0, uv1, frame_padding, bg_col, tint_col) end

--- OBSOLETED in 1.88 (from May 2022)
--- Renamed as name was misleading + removed default value.
---@param want_capture_keyboard bool
---@return void
function _imgui.CaptureKeyboardFromApp(want_capture_keyboard) end


--- Renamed as name was misleading + removed default value.
---@param want_capture_mouse bool
---@return void
function _imgui.CaptureMouseFromApp(want_capture_mouse) end

--- OBSOLETED in 1.86 (from November 2021)
--- Calculate coarse clipping for large list of evenly sized items. Prefer using ImGuiListClipper.
---@param items_count int
---@param items_height float
---@param out_items_display_start int*
---@param out_items_display_end int*
---@return void
function _imgui.CalcListClipping(items_count, items_height, out_items_display_start, out_items_display_end) end

--- OBSOLETED in 1.85 (from August 2021)
---@return float
function _imgui.GetWindowContentRegionWidth() end

--- OBSOLETED in 1.81 (from February 2021)
--- Helper to calculate size from items_count and height_in_items
---@param label const char*
---@param items_count int
---@param height_in_items int
---@return bool
function _imgui.ListBoxHeaderInt(label, items_count, height_in_items) end


---@param label const char*
---@param size ImVec2
---@return bool
function _imgui.ListBoxHeader(label, size) end


---@return void
function _imgui.ListBoxFooter() end

--- OBSOLETED in 1.79 (from August 2020)
--- Bool return value removed. Use IsWindowAppearing() in BeginPopup() instead. Renamed in 1.77, renamed back in 1.79. Sorry!
---@param str_id const char*
---@param mb ImGuiMouseButton
---@return void
function _imgui.OpenPopupContextItem(str_id, mb) end
