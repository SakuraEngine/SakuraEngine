//DO NOT EDIT THIS FILE, IT IS AUTO GENERATED BY CODEGEN
#include "SkrImGui/skr_imgui.config.h"
#include "cimgui/cimgui.h"
extern "C"
{
    #include "lua.h"
    #include "lualib.h"
}
#include <float.h>                  // FLT_MIN, FLT_MAX

            <%def name="check_int(name, index, default)">
            %if default:
                ${name} = luaL_optinteger(L, ${index}, ${default});
            %else:
                ${name} = luaL_checkinteger(L, ${index});
            %endif
            </%def>
            <%def name="check_float(name, index, default)">
            %if default:
                ${name} = luaL_optnumber(L, ${index}, ${default});
            %else:
                ${name} = luaL_checknumber(L, ${index});
            %endif
            </%def>
            <%def name="check_bool(name, index, default)">
            %if default:
                ${name} = lua_isnoneornil(L, ${index}) ? lua_toboolean(L, ${index}) : ${default};
            %else:
                ${name} = lua_toboolean(L, ${index}) != 0;
            %endif
            </%def>
            <%def name="check_string(name, index, default)">
            %if default:
                ${name} = luaL_optstring(L, ${index}, ${default});
            %else:
                ${name} = luaL_checkstring(L, ${index});
            %endif
            </%def>
            <%def name="check_vec2(name, index, default)">
            %if default:
                if (lua_isnoneornil(L, ${index})) {
                    ${name} = ${default};
                } else {
                    ${name}.x = luaL_checknumber(L, ${index});
                    ${name}.y = luaL_checknumber(L, ${index} + 1);
                }
            %else:
                ${name}.x = luaL_checknumber(L, ${index});
                ${name}.y = luaL_checknumber(L, ${index} + 1);
            %endif
            </%def>
            <%def name="check_vec4(name, index, default)">
            %if default:
                if (lua_ilua_isnoneornilsnil(L, ${index})) {
                    ${name} = ${default};
                } else {
                    ${name}.x = luaL_checknumber(L, ${index});
                    ${name}.y = luaL_checknumber(L, ${index} + 1);
                    ${name}.z = luaL_checknumber(L, ${index} + 2);
                    ${name}.w = luaL_checknumber(L, ${index} + 3);
                }
            %else:
                ${name}.x = luaL_checknumber(L, ${index});
                ${name}.y = luaL_checknumber(L, ${index} + 1);
                ${name}.z = luaL_checknumber(L, ${index} + 2);
                ${name}.w = luaL_checknumber(L, ${index} + 3);
            %endif
            </%def>
            <%def name="push_int(name)">
                lua_pushinteger(L, ${name});
            </%def>
            <%def name="push_float(name)">
                lua_pushnumber(L, ${name});
            </%def>
            <%def name="push_bool(name)">
                lua_pushboolean(L, ${name});
            </%def>
            <%def name="push_string(name)">
                lua_pushstring(L, ${name});
            </%def>
            <%def name="push_vec2(name)">
                lua_pushnumber(L, ${name}.x);
                lua_pushnumber(L, ${name}.y);
            </%def>
            <%def name="push_vec4(name)">
                lua_pushnumber(L, ${name}.x);
                lua_pushnumber(L, ${name}.y);
                lua_pushnumber(L, ${name}.z);
                lua_pushnumber(L, ${name}.w);
            </%def>

<%
    supported_types = ["bool", "int", "float", "double", "const char*", "ImVec2", "ImVec4"]
    check_methods = {
        "bool": check_bool,
        "int": check_int,
        "float": check_float,
        "double": check_float,
        "const char*": check_string,
        "ImVec2": check_vec2,
        "ImVec4": check_vec4
    }
    stack_sizes = {
        "bool": 1,
        "int": 1,
        "float": 1,
        "double": 1,
        "const char*": 1,
        "ImVec2": 2,
        "ImVec4": 4,
        "ImColor": 4
    }
    push_methods = {
        "bool" : push_bool,
        "int" : push_int,  
        "float" : push_float,
        "double" : push_float,
        "const char*" : push_string,
        "ImVec2" : push_vec2,
        "ImVec4" : push_vec4
    }

    def rm_prefix(name):
        if name.startswith("ImGui_"):
            return name[6:]
        elif name.startswith("ImGui"):
            return name[5:]
        return name

    def underlying_type(declaration):
        if declaration == "const char*":
            return "const char*"
        if declaration.endswith("*"):
            declaration = declaration[:-1]
        for t in meta.typedefs:
            if t.name == declaration:
                return t.type.declaration
        return declaration
    
    def is_inout(declaration):
        return declaration.endswith("*") and not declaration == "const char*"

    def is_function_pointer(type):
        return hasattr(type, "type_details") and type.type_details.flavour == "function_pointer"

    def is_function_supported(func, isCallback=False):
        prevCallback = False
        arguments = func.arguments[1:] if isCallback else func.arguments
        for arg in arguments:
            if prevCallback:
                prevCallback = False
                continue
            if arg.is_varargs:
                continue
            if is_function_pointer(arg.type):
                if is_function_supported(arg.type.type_details, True):
                    prevCallback = True
                    continue
                else:
                    return False
            if underlying_type(arg.type.declaration) not in supported_types:
                return False
        ret = underlying_type(func.return_type.declaration)
        if ret != "void" and ret not in supported_types:
            return False
        return True
%>

SKR_IMGUI_EXTERN_C SKR_IMGUI_API void skr_lua_bind_imgui(lua_State* L)
{ 
    lua_getglobal(L, "skr");
    lua_newtable(L);

    //bind enums
%for enum in meta.enums:
%for element in enum.elements:
    lua_pushinteger(L, ${element.name});
    lua_setfield(L, -2, "${rm_prefix(element.name)}");
%endfor
%endfor

%for function in meta.functions:
%if is_function_supported(function):
    {
        auto trampoline = +[](lua_State* L) -> int
        {
        <%
            inout_args = []
            argexprs = []
            currParam = 1
            rut = underlying_type(function.return_type.declaration)
            callbackArg = None
        %>
        %for arg in function.arguments:
        <%
            if arg.is_varargs:
                continue
            if is_function_pointer(arg.type):
                callbackArg = arg
                continue
            ut = underlying_type(arg.type.declaration)
            if not callbackArg and (arg.is_array or is_inout(arg.type.declaration)):
                inout_args.append(arg)
            default = arg.default_value.replace("(", "{").replace(")", "}") if hasattr(arg, "default_value") else None
        %>
        %if arg.is_array:
            ${ut} ${arg.name}[${arg.array_bounds}];
        %for i in range(int(arg.array_bounds)):
            ${check_methods[ut]("%s[%d]"%(arg.name, i), currParam, None)}
        <% currParam += stack_sizes[ut] %>
        %endfor
        %elif callbackArg:
            <%
                ct = callbackArg.type.declaration
                cargs = callbackArg.type.type_details.arguments
                crut = underlying_type(callbackArg.type.type_details.return_type.declaration)
                currCRet = 0
                CRetCount = 0
                currCArg = 0
            %>
            if(!lua_isfunction(L, ${currParam}))
                luaL_error(L, "argument ${callbackArg.name} must be a function");
            ${ct} = +[]${ct[ct.rfind("("):]}
            {
                lua_State* L = (lua_State*)${cargs[0].name};
                lua_pushvalue(L, ${currParam});
            %for cArg in cargs[1:]:
                <% caut = underlying_type(cArg.type.declaration) %>
            %if not is_inout(cArg.type.declaration):
                ${push_methods[caut](cArg.name)}
                <% currCArg += stack_sizes[caut] %>
            %else:
                <% CRetCount += stack_sizes[caut] %>
            %endif
            %endfor
            %if crut != "void":
                <% CRetCount += stack_sizes[crut]%>
                ${crut} ret = {};
                if(lua_pcall(L, ${currCArg}, ${CRetCount}, 0) != LUA_OK)
                {
                    lua_getglobal(L, "skr");
                    lua_getfield(L, -1, "log_error");
                    lua_pushvalue(L, -3);
                    lua_call(L, 1, 0);
                    lua_pop(L, 2);
                    return ret;
                }
                ${check_methods[crut]("ret", -CRetCount+currCRet, None)}
                <% currCRet += stack_sizes[crut] %>
            %else:
                if(lua_pcall(L, ${currCArg}, 0, 0) != LUA_OK)
                    luaL_error(L, lua_tostring(L, -1));
            %endif
            %for cArg in cargs[1:]:
                <% caut = underlying_type(cArg.type.declaration) %>
            %if is_inout(cArg.type.declaration):
                ${check_methods[caut]("*"+cArg.name, -CRetCount+currCRet, None)}
                <% currCRet += stack_sizes[caut] %>
            %endif
            %endfor

                lua_pop(L, ${CRetCount});
            %if crut != "void":
                return ret;
            %endif
            };
            ${arg.type.declaration} ${arg.name} = L;
            <% 
                currParam += 1
                callbackArg = None
            %>
        %else:
        %if is_inout(arg.type.declaration):
            ${ut} _${arg.name};
            ${check_methods[ut]("_%s"%arg.name, currParam, None)}
            ${ut}* ${arg.name} = &_${arg.name};
        %else:
            ${ut} ${arg.name};
            ${check_methods[ut](arg.name, currParam, default)}
        %endif
        <% currParam += stack_sizes[ut] %>
        %endif
        %endfor
        <%
            currOut = 0
        %>
        %if rut != "void":
            ${rut} ret = ${function.name}(${", ".join([arg.name for arg in function.arguments if not arg.is_varargs])});
            ${push_methods[rut]("ret")}
            <% currOut += stack_sizes[rut] %>
        %else:
            ${function.name}(${", ".join([arg.name for arg in function.arguments if not arg.is_varargs])});
        %endif
        %for arg in inout_args:
        <% ut = underlying_type(arg.type.declaration) %>
        %if arg.is_array:
        %for i in range(int(arg.array_bounds)):
            ${push_methods[ut]("%s[%d]"%(arg.name, i))}
            <% currOut += stack_sizes[ut] %>
        %endfor
        %else:
            ${push_methods[ut]("_%s"%arg.name)}
            <% currOut += stack_sizes[ut] %>
        %endif
        %endfor
            return ${currOut};
        };
        lua_pushcfunction(L, trampoline, "${rm_prefix(function.name)}");
        lua_setfield(L, -2, "${rm_prefix(function.name)}");
    }
%endif
%endfor
    lua_setfield(L, -2, "imgui");
}